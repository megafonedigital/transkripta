{"ast":null,"code":"import config from '../config/env';\n\n/**\n * Serviço para verificação e processamento de webhooks do Replicate\n * Implementa verificação HMAC SHA-256 para autenticidade\n */\nclass WebhookService {\n  constructor() {\n    this.webhookSecret = config.replicate.webhookSecret;\n  }\n\n  /**\n   * Verifica se o webhook está configurado\n   */\n  isConfigured() {\n    return !!this.webhookSecret;\n  }\n\n  /**\n   * Verifica a autenticidade de um webhook usando HMAC SHA-256\n   * @param {string} payload - Corpo da requisição (raw)\n   * @param {string} webhookId - ID do webhook (header webhook-id)\n   * @param {string} webhookTimestamp - Timestamp do webhook (header webhook-timestamp)\n   * @param {string} webhookSignature - Assinatura do webhook (header webhook-signature)\n   * @returns {boolean} - True se o webhook for válido\n   */\n  async verifyWebhook(payload, webhookId, webhookTimestamp, webhookSignature) {\n    if (!this.isConfigured()) {\n      console.warn('Webhook secret não configurado');\n      return false;\n    }\n    try {\n      // Verificar timestamp para prevenir replay attacks (tolerância de 5 minutos)\n      const currentTime = Math.floor(Date.now() / 1000);\n      const webhookTime = parseInt(webhookTimestamp);\n      const timeDiff = Math.abs(currentTime - webhookTime);\n      if (timeDiff > 300) {\n        // 5 minutos\n        console.warn('Webhook timestamp muito antigo ou futuro:', timeDiff);\n        return false;\n      }\n\n      // Construir o conteúdo assinado: id.timestamp.payload\n      const signedContent = `${webhookId}.${webhookTimestamp}.${payload}`;\n\n      // Extrair a chave base64 (remover prefixo whsec_)\n      const secretKey = this.webhookSecret.startsWith('whsec_') ? this.webhookSecret.substring(6) : this.webhookSecret;\n\n      // Calcular HMAC SHA-256\n      const expectedSignature = await this.calculateHMAC(signedContent, secretKey);\n\n      // Extrair assinaturas do header (formato: \"v1,signature1 v1,signature2\")\n      const signatures = webhookSignature.split(' ').map(sig => {\n        const parts = sig.split(',');\n        return parts.length === 2 ? parts[1] : sig;\n      });\n\n      // Verificar se alguma assinatura coincide (comparação segura)\n      return signatures.some(sig => this.secureCompare(expectedSignature, sig));\n    } catch (error) {\n      console.error('Erro ao verificar webhook:', error);\n      return false;\n    }\n  }\n\n  /**\n   * Calcula HMAC SHA-256\n   * @param {string} data - Dados para assinar\n   * @param {string} key - Chave secreta (base64)\n   * @returns {Promise<string>} - Assinatura HMAC em base64\n   */\n  async calculateHMAC(data, key) {\n    // Converter chave base64 para ArrayBuffer\n    const keyBuffer = this.base64ToArrayBuffer(key);\n\n    // Converter dados para ArrayBuffer\n    const dataBuffer = new TextEncoder().encode(data);\n\n    // Importar chave para WebCrypto\n    const cryptoKey = await crypto.subtle.importKey('raw', keyBuffer, {\n      name: 'HMAC',\n      hash: 'SHA-256'\n    }, false, ['sign']);\n\n    // Calcular HMAC\n    const signature = await crypto.subtle.sign('HMAC', cryptoKey, dataBuffer);\n\n    // Converter para base64\n    return this.arrayBufferToBase64(signature);\n  }\n\n  /**\n   * Converte base64 para ArrayBuffer\n   * @param {string} base64 - String base64\n   * @returns {ArrayBuffer} - ArrayBuffer\n   */\n  base64ToArrayBuffer(base64) {\n    const binaryString = atob(base64);\n    const bytes = new Uint8Array(binaryString.length);\n    for (let i = 0; i < binaryString.length; i++) {\n      bytes[i] = binaryString.charCodeAt(i);\n    }\n    return bytes.buffer;\n  }\n\n  /**\n   * Converte ArrayBuffer para base64\n   * @param {ArrayBuffer} buffer - ArrayBuffer\n   * @returns {string} - String base64\n   */\n  arrayBufferToBase64(buffer) {\n    const bytes = new Uint8Array(buffer);\n    let binary = '';\n    for (let i = 0; i < bytes.byteLength; i++) {\n      binary += String.fromCharCode(bytes[i]);\n    }\n    return btoa(binary);\n  }\n\n  /**\n   * Comparação segura de strings para prevenir timing attacks\n   * @param {string} a - Primeira string\n   * @param {string} b - Segunda string\n   * @returns {boolean} - True se as strings forem iguais\n   */\n  secureCompare(a, b) {\n    if (a.length !== b.length) {\n      return false;\n    }\n    let result = 0;\n    for (let i = 0; i < a.length; i++) {\n      result |= a.charCodeAt(i) ^ b.charCodeAt(i);\n    }\n    return result === 0;\n  }\n\n  /**\n   * Processa um webhook do Replicate\n   * @param {Object} webhookData - Dados do webhook\n   * @returns {Object} - Resultado do processamento\n   */\n  processWebhook(webhookData) {\n    try {\n      const {\n        id,\n        status,\n        output,\n        error,\n        logs\n      } = webhookData;\n\n      // Atualizar informações da predição no localStorage\n      if (typeof window !== 'undefined' && window.localStorage) {\n        const predictions = JSON.parse(localStorage.getItem('replicate_predictions') || '{}');\n        if (predictions[id]) {\n          predictions[id] = {\n            ...predictions[id],\n            status,\n            output,\n            error,\n            logs,\n            updatedAt: new Date().toISOString(),\n            webhookReceived: true\n          };\n          localStorage.setItem('replicate_predictions', JSON.stringify(predictions));\n\n          // Disparar evento customizado para notificar componentes\n          window.dispatchEvent(new CustomEvent('replicateWebhookReceived', {\n            detail: {\n              predictionId: id,\n              status,\n              output,\n              error\n            }\n          }));\n        }\n      }\n      return {\n        success: true,\n        predictionId: id,\n        status,\n        message: this.getStatusMessage(status)\n      };\n    } catch (error) {\n      console.error('Erro ao processar webhook:', error);\n      return {\n        success: false,\n        error: error.message\n      };\n    }\n  }\n\n  /**\n   * Obtém mensagem amigável para o status\n   * @param {string} status - Status da predição\n   * @returns {string} - Mensagem amigável\n   */\n  getStatusMessage(status) {\n    const messages = {\n      'starting': 'Iniciando processamento...',\n      'processing': 'Processando transcrição...',\n      'succeeded': 'Transcrição concluída com sucesso!',\n      'failed': 'Erro no processamento da transcrição',\n      'canceled': 'Processamento cancelado'\n    };\n    return messages[status] || `Status: ${status}`;\n  }\n\n  /**\n   * Extrai texto da transcrição do output do Whisper\n   * @param {Object} output - Output da predição\n   * @returns {string} - Texto transcrito\n   */\n  extractTranscriptionText(output) {\n    if (!output) return '';\n\n    // O Whisper pode retornar diferentes formatos\n    if (typeof output === 'string') {\n      return output;\n    }\n    if (output.text) {\n      return output.text;\n    }\n    if (output.transcription) {\n      return output.transcription;\n    }\n    if (output.segments && Array.isArray(output.segments)) {\n      return output.segments.map(segment => segment.text || '').join(' ');\n    }\n    return JSON.stringify(output);\n  }\n\n  /**\n   * Obtém informações detalhadas da transcrição\n   * @param {Object} output - Output da predição\n   * @returns {Object} - Informações detalhadas\n   */\n  getTranscriptionDetails(output) {\n    if (!output) return null;\n    return {\n      text: this.extractTranscriptionText(output),\n      segments: output.segments || [],\n      language: output.language || 'unknown',\n      duration: output.duration || null,\n      wordCount: this.extractTranscriptionText(output).split(/\\s+/).length\n    };\n  }\n}\n\n// Instância singleton\nconst webhookService = new WebhookService();\nexport default webhookService;","map":{"version":3,"names":["config","WebhookService","constructor","webhookSecret","replicate","isConfigured","verifyWebhook","payload","webhookId","webhookTimestamp","webhookSignature","console","warn","currentTime","Math","floor","Date","now","webhookTime","parseInt","timeDiff","abs","signedContent","secretKey","startsWith","substring","expectedSignature","calculateHMAC","signatures","split","map","sig","parts","length","some","secureCompare","error","data","key","keyBuffer","base64ToArrayBuffer","dataBuffer","TextEncoder","encode","cryptoKey","crypto","subtle","importKey","name","hash","signature","sign","arrayBufferToBase64","base64","binaryString","atob","bytes","Uint8Array","i","charCodeAt","buffer","binary","byteLength","String","fromCharCode","btoa","a","b","result","processWebhook","webhookData","id","status","output","logs","window","localStorage","predictions","JSON","parse","getItem","updatedAt","toISOString","webhookReceived","setItem","stringify","dispatchEvent","CustomEvent","detail","predictionId","success","message","getStatusMessage","messages","extractTranscriptionText","text","transcription","segments","Array","isArray","segment","join","getTranscriptionDetails","language","duration","wordCount","webhookService"],"sources":["C:/Users/Afonso/Desktop/Transkipta/src/services/webhookService.js"],"sourcesContent":["import config from '../config/env';\n\n/**\n * Serviço para verificação e processamento de webhooks do Replicate\n * Implementa verificação HMAC SHA-256 para autenticidade\n */\nclass WebhookService {\n  constructor() {\n    this.webhookSecret = config.replicate.webhookSecret;\n  }\n\n  /**\n   * Verifica se o webhook está configurado\n   */\n  isConfigured() {\n    return !!this.webhookSecret;\n  }\n\n  /**\n   * Verifica a autenticidade de um webhook usando HMAC SHA-256\n   * @param {string} payload - Corpo da requisição (raw)\n   * @param {string} webhookId - ID do webhook (header webhook-id)\n   * @param {string} webhookTimestamp - Timestamp do webhook (header webhook-timestamp)\n   * @param {string} webhookSignature - Assinatura do webhook (header webhook-signature)\n   * @returns {boolean} - True se o webhook for válido\n   */\n  async verifyWebhook(payload, webhookId, webhookTimestamp, webhookSignature) {\n    if (!this.isConfigured()) {\n      console.warn('Webhook secret não configurado');\n      return false;\n    }\n\n    try {\n      // Verificar timestamp para prevenir replay attacks (tolerância de 5 minutos)\n      const currentTime = Math.floor(Date.now() / 1000);\n      const webhookTime = parseInt(webhookTimestamp);\n      const timeDiff = Math.abs(currentTime - webhookTime);\n      \n      if (timeDiff > 300) { // 5 minutos\n        console.warn('Webhook timestamp muito antigo ou futuro:', timeDiff);\n        return false;\n      }\n\n      // Construir o conteúdo assinado: id.timestamp.payload\n      const signedContent = `${webhookId}.${webhookTimestamp}.${payload}`;\n      \n      // Extrair a chave base64 (remover prefixo whsec_)\n      const secretKey = this.webhookSecret.startsWith('whsec_') \n        ? this.webhookSecret.substring(6) \n        : this.webhookSecret;\n      \n      // Calcular HMAC SHA-256\n      const expectedSignature = await this.calculateHMAC(signedContent, secretKey);\n      \n      // Extrair assinaturas do header (formato: \"v1,signature1 v1,signature2\")\n      const signatures = webhookSignature.split(' ').map(sig => {\n        const parts = sig.split(',');\n        return parts.length === 2 ? parts[1] : sig;\n      });\n      \n      // Verificar se alguma assinatura coincide (comparação segura)\n      return signatures.some(sig => this.secureCompare(expectedSignature, sig));\n      \n    } catch (error) {\n      console.error('Erro ao verificar webhook:', error);\n      return false;\n    }\n  }\n\n  /**\n   * Calcula HMAC SHA-256\n   * @param {string} data - Dados para assinar\n   * @param {string} key - Chave secreta (base64)\n   * @returns {Promise<string>} - Assinatura HMAC em base64\n   */\n  async calculateHMAC(data, key) {\n    // Converter chave base64 para ArrayBuffer\n    const keyBuffer = this.base64ToArrayBuffer(key);\n    \n    // Converter dados para ArrayBuffer\n    const dataBuffer = new TextEncoder().encode(data);\n    \n    // Importar chave para WebCrypto\n    const cryptoKey = await crypto.subtle.importKey(\n      'raw',\n      keyBuffer,\n      { name: 'HMAC', hash: 'SHA-256' },\n      false,\n      ['sign']\n    );\n    \n    // Calcular HMAC\n    const signature = await crypto.subtle.sign('HMAC', cryptoKey, dataBuffer);\n    \n    // Converter para base64\n    return this.arrayBufferToBase64(signature);\n  }\n\n  /**\n   * Converte base64 para ArrayBuffer\n   * @param {string} base64 - String base64\n   * @returns {ArrayBuffer} - ArrayBuffer\n   */\n  base64ToArrayBuffer(base64) {\n    const binaryString = atob(base64);\n    const bytes = new Uint8Array(binaryString.length);\n    for (let i = 0; i < binaryString.length; i++) {\n      bytes[i] = binaryString.charCodeAt(i);\n    }\n    return bytes.buffer;\n  }\n\n  /**\n   * Converte ArrayBuffer para base64\n   * @param {ArrayBuffer} buffer - ArrayBuffer\n   * @returns {string} - String base64\n   */\n  arrayBufferToBase64(buffer) {\n    const bytes = new Uint8Array(buffer);\n    let binary = '';\n    for (let i = 0; i < bytes.byteLength; i++) {\n      binary += String.fromCharCode(bytes[i]);\n    }\n    return btoa(binary);\n  }\n\n  /**\n   * Comparação segura de strings para prevenir timing attacks\n   * @param {string} a - Primeira string\n   * @param {string} b - Segunda string\n   * @returns {boolean} - True se as strings forem iguais\n   */\n  secureCompare(a, b) {\n    if (a.length !== b.length) {\n      return false;\n    }\n    \n    let result = 0;\n    for (let i = 0; i < a.length; i++) {\n      result |= a.charCodeAt(i) ^ b.charCodeAt(i);\n    }\n    \n    return result === 0;\n  }\n\n  /**\n   * Processa um webhook do Replicate\n   * @param {Object} webhookData - Dados do webhook\n   * @returns {Object} - Resultado do processamento\n   */\n  processWebhook(webhookData) {\n    try {\n      const { id, status, output, error, logs } = webhookData;\n      \n      // Atualizar informações da predição no localStorage\n      if (typeof window !== 'undefined' && window.localStorage) {\n        const predictions = JSON.parse(localStorage.getItem('replicate_predictions') || '{}');\n        \n        if (predictions[id]) {\n          predictions[id] = {\n            ...predictions[id],\n            status,\n            output,\n            error,\n            logs,\n            updatedAt: new Date().toISOString(),\n            webhookReceived: true\n          };\n          \n          localStorage.setItem('replicate_predictions', JSON.stringify(predictions));\n          \n          // Disparar evento customizado para notificar componentes\n          window.dispatchEvent(new CustomEvent('replicateWebhookReceived', {\n            detail: { predictionId: id, status, output, error }\n          }));\n        }\n      }\n      \n      return {\n        success: true,\n        predictionId: id,\n        status,\n        message: this.getStatusMessage(status)\n      };\n      \n    } catch (error) {\n      console.error('Erro ao processar webhook:', error);\n      return {\n        success: false,\n        error: error.message\n      };\n    }\n  }\n\n  /**\n   * Obtém mensagem amigável para o status\n   * @param {string} status - Status da predição\n   * @returns {string} - Mensagem amigável\n   */\n  getStatusMessage(status) {\n    const messages = {\n      'starting': 'Iniciando processamento...',\n      'processing': 'Processando transcrição...',\n      'succeeded': 'Transcrição concluída com sucesso!',\n      'failed': 'Erro no processamento da transcrição',\n      'canceled': 'Processamento cancelado'\n    };\n    \n    return messages[status] || `Status: ${status}`;\n  }\n\n  /**\n   * Extrai texto da transcrição do output do Whisper\n   * @param {Object} output - Output da predição\n   * @returns {string} - Texto transcrito\n   */\n  extractTranscriptionText(output) {\n    if (!output) return '';\n    \n    // O Whisper pode retornar diferentes formatos\n    if (typeof output === 'string') {\n      return output;\n    }\n    \n    if (output.text) {\n      return output.text;\n    }\n    \n    if (output.transcription) {\n      return output.transcription;\n    }\n    \n    if (output.segments && Array.isArray(output.segments)) {\n      return output.segments.map(segment => segment.text || '').join(' ');\n    }\n    \n    return JSON.stringify(output);\n  }\n\n  /**\n   * Obtém informações detalhadas da transcrição\n   * @param {Object} output - Output da predição\n   * @returns {Object} - Informações detalhadas\n   */\n  getTranscriptionDetails(output) {\n    if (!output) return null;\n    \n    return {\n      text: this.extractTranscriptionText(output),\n      segments: output.segments || [],\n      language: output.language || 'unknown',\n      duration: output.duration || null,\n      wordCount: this.extractTranscriptionText(output).split(/\\s+/).length\n    };\n  }\n}\n\n// Instância singleton\nconst webhookService = new WebhookService();\n\nexport default webhookService;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}