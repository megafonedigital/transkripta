{"ast":null,"code":"import axios from 'axios';\nimport config from '../config/env';\n\n// Configurações das APIs\nconst TRANSCRIPTION_WEBHOOK_URL = config.transcriptionWebhook.url;\nconst TRANSCRIPTION_WEBHOOK_SECRET = config.transcriptionWebhook.secret;\nconst TRANSCRIPTION_WEBHOOK_TIMEOUT = config.transcriptionWebhook.timeout;\nconst SOCIAL_WEBHOOK_URL = config.socialWebhook.url;\nconst SOCIAL_WEBHOOK_SECRET = config.socialWebhook.secret;\nconst SOCIAL_WEBHOOK_TIMEOUT = config.socialWebhook.timeout;\nconst API_TIMEOUT = config.api.timeout;\n\n// Transcription Webhook API instance\nconst transcriptionWebhookApi = axios.create({\n  timeout: TRANSCRIPTION_WEBHOOK_TIMEOUT,\n  headers: {\n    'Content-Type': 'application/json',\n    'X-Webhook-Secret': TRANSCRIPTION_WEBHOOK_SECRET\n  }\n});\n\n// Social Downloader Webhook API instance\nconst socialWebhookApi = axios.create({\n  timeout: SOCIAL_WEBHOOK_TIMEOUT,\n  headers: {\n    'Content-Type': 'application/json',\n    'X-Webhook-Secret': SOCIAL_WEBHOOK_SECRET\n  }\n});\n\n// Video Processing Functions via Webhook\nexport const processVideoUrl = async (url, options = {}) => {\n  try {\n    console.log('Enviando URL para webhook:', url);\n    const requestData = {\n      url: url,\n      format: options.format || 'mp4',\n      quality: options.quality || '720p',\n      audioOnly: options.audioOnly || false,\n      timestamp: Date.now()\n    };\n    console.log('Dados da requisição webhook:', requestData);\n    const response = await socialWebhookApi.post(SOCIAL_WEBHOOK_URL, requestData);\n    console.log('Resposta do webhook:', response.data);\n\n    // Nova estrutura de resposta: array com objetos contendo status, url e filename\n    if (response.data && Array.isArray(response.data) && response.data.length > 0) {\n      const videoData = response.data[0]; // Pega o primeiro item do array\n\n      if ((videoData.status === 'tunnel' || videoData.status === 'redirect') && videoData.url && videoData.filename) {\n        return {\n          status: videoData.status,\n          videoUrl: videoData.url,\n          audioUrl: videoData.url,\n          // Mesmo URL para áudio e vídeo\n          title: videoData.filename.replace(/\\.[^/.]+$/, ''),\n          // Remove extensão do filename\n          filename: videoData.filename,\n          tunnelUrl: videoData.url,\n          // Mantém compatibilidade\n          directUrl: videoData.url\n        };\n      }\n    }\n\n    // Fallback para estrutura antiga se necessário\n    if (response.data && response.data.success) {\n      return {\n        videoUrl: response.data.videoUrl,\n        audioUrl: response.data.audioUrl,\n        title: response.data.title,\n        duration: response.data.duration,\n        thumbnail: response.data.thumbnail\n      };\n    }\n    throw new Error('Webhook não retornou dados válidos');\n  } catch (error) {\n    console.error('Erro no processamento via webhook:', error);\n    throw handleApiError(error);\n  }\n};\n\n// Download file from URL - Modified for automatic download\nexport const downloadFromUrl = async (url, filename, isDirect = false) => {\n  try {\n    console.log('Fazendo download do arquivo:', url);\n\n    // For direct URLs, try to download automatically first\n    if (isDirect) {\n      console.log('Tentando download automático de URL direta:', url);\n      try {\n        // Improve filename with proper extension if missing\n        let downloadFilename = filename || 'download';\n        if (!downloadFilename.includes('.')) {\n          // Try to detect extension from URL\n          const urlPath = new URL(url).pathname;\n          const urlExtension = urlPath.split('.').pop();\n          if (urlExtension && urlExtension.length <= 4) {\n            downloadFilename += '.' + urlExtension;\n          } else {\n            downloadFilename += '.mp4'; // Default to mp4\n          }\n        }\n\n        // Try fetch first for better compatibility with Instagram URLs\n        try {\n          const response = await fetch(url, {\n            mode: 'no-cors'\n          });\n          if (response.type === 'opaque' || response.ok) {\n            // If fetch works, create download link\n            const link = document.createElement('a');\n            link.href = url;\n            link.download = downloadFilename;\n            link.target = '_blank';\n            link.style.display = 'none';\n            document.body.appendChild(link);\n            link.click();\n            document.body.removeChild(link);\n            return;\n          }\n        } catch (fetchError) {\n          console.log('Fetch falhou, tentando link direto:', fetchError);\n        }\n\n        // Fallback: Create a temporary link to trigger download\n        const link = document.createElement('a');\n        link.href = url;\n        link.download = downloadFilename;\n        link.target = '_blank';\n        link.style.display = 'none';\n        document.body.appendChild(link);\n        link.click();\n        document.body.removeChild(link);\n        return;\n      } catch (directError) {\n        console.log('Download automático falhou, redirecionando:', directError);\n        window.open(url, '_blank');\n        return;\n      }\n    }\n    const response = await axios.get(url, {\n      responseType: 'blob',\n      timeout: API_TIMEOUT * 3,\n      // Mais tempo para download de arquivos grandes\n      onDownloadProgress: progressEvent => {\n        if (progressEvent.total) {\n          const progress = Math.round(progressEvent.loaded * 100 / progressEvent.total);\n          console.log(`Download progress: ${progress}%`);\n        }\n      }\n    });\n\n    // Create download link\n    const blob = new Blob([response.data]);\n    const downloadUrl = window.URL.createObjectURL(blob);\n    const link = document.createElement('a');\n    link.href = downloadUrl;\n    link.download = filename || 'download';\n    document.body.appendChild(link);\n    link.click();\n    document.body.removeChild(link);\n    window.URL.revokeObjectURL(downloadUrl);\n    return response.data;\n  } catch (error) {\n    console.error('Erro no download do arquivo:', error);\n    throw handleApiError(error);\n  }\n};\n\n// Process tunnel URL for transcription\nexport const processTunnelUrl = async tunnelUrl => {\n  try {\n    console.log('Processando URL do tunnel para transcrição:', tunnelUrl);\n    const response = await axios.get(tunnelUrl, {\n      responseType: 'blob',\n      timeout: API_TIMEOUT * 5,\n      // Mais tempo para arquivos grandes\n      onDownloadProgress: progressEvent => {\n        if (progressEvent.total) {\n          const progress = Math.round(progressEvent.loaded * 100 / progressEvent.total);\n          console.log(`Download progress: ${progress}%`);\n        }\n      }\n    });\n\n    // Return blob for transcription\n    return response.data;\n  } catch (error) {\n    console.error('Erro ao processar URL do tunnel:', error);\n    throw handleApiError(error);\n  }\n};\n\n// Get direct download link for social download\nexport const getTunnelDownloadInfo = videoData => {\n  if ((videoData.status === 'tunnel' || videoData.status === 'redirect') && videoData.tunnelUrl) {\n    return {\n      downloadUrl: videoData.tunnelUrl,\n      filename: videoData.filename,\n      title: videoData.title\n    };\n  }\n\n  // Fallback para estrutura antiga\n  return {\n    downloadUrl: videoData.videoUrl || videoData.audioUrl,\n    filename: videoData.title ? `${videoData.title}.mp4` : 'download.mp4',\n    title: videoData.title\n  };\n};\n\n// Webhook processing functions replace previous download methods\n\n// Transcription Functions\n// Função transcribeAudio removida - agora usando apenas Replicate Whisper\n\n// Utility Functions\n\nexport const validateVideoUrl = url => {\n  const patterns = {\n    youtube: /(?:youtube\\.com\\/(?:[^\\/]+\\/.+\\/|(?:v|e(?:mbed)?)\\/|.*[?&]v=|shorts\\/)|youtu\\.be\\/)/,\n    instagram: /(?:instagram\\.com\\/(?:p|reel|tv)\\/)/,\n    tiktok: /(?:tiktok\\.com\\/@[^\\/]+\\/video\\/|vm\\.tiktok\\.com\\/)/\n  };\n  for (const [platform, pattern] of Object.entries(patterns)) {\n    if (pattern.test(url)) {\n      return platform;\n    }\n  }\n  return null;\n};\n\n// File Processing\nexport const convertToAudio = async videoBlob => {\n  return new Promise((resolve, reject) => {\n    const audio = document.createElement('audio');\n    const url = URL.createObjectURL(videoBlob);\n    audio.src = url;\n    audio.addEventListener('loadedmetadata', () => {\n      // For now, we'll return the original blob\n      // In a real implementation, you might want to use FFmpeg.js\n      resolve(videoBlob);\n      URL.revokeObjectURL(url);\n    });\n    audio.addEventListener('error', () => {\n      reject(new Error('Erro ao processar o arquivo de áudio'));\n      URL.revokeObjectURL(url);\n    });\n  });\n};\n\n// Error Handling\nexport const handleApiError = error => {\n  if (error.response) {\n    var _error$response$data;\n    // Server responded with error status\n    const status = error.response.status;\n    const message = ((_error$response$data = error.response.data) === null || _error$response$data === void 0 ? void 0 : _error$response$data.message) || error.message;\n    switch (status) {\n      case 401:\n        return 'Chave de API inválida ou expirada';\n      case 403:\n        return 'Acesso negado. Verifique suas permissões';\n      case 429:\n        return 'Limite de requisições excedido. Tente novamente mais tarde';\n      case 500:\n        return 'Erro interno do servidor';\n      default:\n        return `Erro ${status}: ${message}`;\n    }\n  } else if (error.request) {\n    // Network error\n    return 'Erro de conexão. Verifique sua internet';\n  } else {\n    // Other error\n    return error.message || 'Erro desconhecido';\n  }\n};","map":{"version":3,"names":["axios","config","TRANSCRIPTION_WEBHOOK_URL","transcriptionWebhook","url","TRANSCRIPTION_WEBHOOK_SECRET","secret","TRANSCRIPTION_WEBHOOK_TIMEOUT","timeout","SOCIAL_WEBHOOK_URL","socialWebhook","SOCIAL_WEBHOOK_SECRET","SOCIAL_WEBHOOK_TIMEOUT","API_TIMEOUT","api","transcriptionWebhookApi","create","headers","socialWebhookApi","processVideoUrl","options","console","log","requestData","format","quality","audioOnly","timestamp","Date","now","response","post","data","Array","isArray","length","videoData","status","filename","videoUrl","audioUrl","title","replace","tunnelUrl","directUrl","success","duration","thumbnail","Error","error","handleApiError","downloadFromUrl","isDirect","downloadFilename","includes","urlPath","URL","pathname","urlExtension","split","pop","fetch","mode","type","ok","link","document","createElement","href","download","target","style","display","body","appendChild","click","removeChild","fetchError","directError","window","open","get","responseType","onDownloadProgress","progressEvent","total","progress","Math","round","loaded","blob","Blob","downloadUrl","createObjectURL","revokeObjectURL","processTunnelUrl","getTunnelDownloadInfo","validateVideoUrl","patterns","youtube","instagram","tiktok","platform","pattern","Object","entries","test","convertToAudio","videoBlob","Promise","resolve","reject","audio","src","addEventListener","_error$response$data","message","request"],"sources":["C:/Users/Afonso/Desktop/Transkipta/src/services/apiService.js"],"sourcesContent":["import axios from 'axios';\r\nimport config from '../config/env';\r\n\r\n// Configurações das APIs\r\nconst TRANSCRIPTION_WEBHOOK_URL = config.transcriptionWebhook.url;\r\nconst TRANSCRIPTION_WEBHOOK_SECRET = config.transcriptionWebhook.secret;\r\nconst TRANSCRIPTION_WEBHOOK_TIMEOUT = config.transcriptionWebhook.timeout;\r\nconst SOCIAL_WEBHOOK_URL = config.socialWebhook.url;\r\nconst SOCIAL_WEBHOOK_SECRET = config.socialWebhook.secret;\r\nconst SOCIAL_WEBHOOK_TIMEOUT = config.socialWebhook.timeout;\r\nconst API_TIMEOUT = config.api.timeout;\r\n\r\n// Transcription Webhook API instance\r\nconst transcriptionWebhookApi = axios.create({\r\n  timeout: TRANSCRIPTION_WEBHOOK_TIMEOUT,\r\n  headers: {\r\n    'Content-Type': 'application/json',\r\n    'X-Webhook-Secret': TRANSCRIPTION_WEBHOOK_SECRET\r\n  }\r\n});\r\n\r\n// Social Downloader Webhook API instance\r\nconst socialWebhookApi = axios.create({\r\n  timeout: SOCIAL_WEBHOOK_TIMEOUT,\r\n  headers: {\r\n    'Content-Type': 'application/json',\r\n    'X-Webhook-Secret': SOCIAL_WEBHOOK_SECRET\r\n  }\r\n});\r\n\r\n// Video Processing Functions via Webhook\r\nexport const processVideoUrl = async (url, options = {}) => {\r\n  try {\r\n    console.log('Enviando URL para webhook:', url);\r\n    \r\n    const requestData = {\r\n      url: url,\r\n      format: options.format || 'mp4',\r\n      quality: options.quality || '720p',\r\n      audioOnly: options.audioOnly || false,\r\n      timestamp: Date.now()\r\n    };\r\n    \r\n    console.log('Dados da requisição webhook:', requestData);\r\n    \r\n    const response = await socialWebhookApi.post(SOCIAL_WEBHOOK_URL, requestData);\r\n    \r\n    console.log('Resposta do webhook:', response.data);\r\n    \r\n    // Nova estrutura de resposta: array com objetos contendo status, url e filename\r\n    if (response.data && Array.isArray(response.data) && response.data.length > 0) {\r\n      const videoData = response.data[0]; // Pega o primeiro item do array\r\n      \r\n      if ((videoData.status === 'tunnel' || videoData.status === 'redirect') && videoData.url && videoData.filename) {\r\n        return {\r\n          status: videoData.status,\r\n          videoUrl: videoData.url,\r\n          audioUrl: videoData.url, // Mesmo URL para áudio e vídeo\r\n          title: videoData.filename.replace(/\\.[^/.]+$/, ''), // Remove extensão do filename\r\n          filename: videoData.filename,\r\n          tunnelUrl: videoData.url, // Mantém compatibilidade\r\n          directUrl: videoData.url\r\n        };\r\n      }\r\n    }\r\n    \r\n    // Fallback para estrutura antiga se necessário\r\n    if (response.data && response.data.success) {\r\n      return {\r\n        videoUrl: response.data.videoUrl,\r\n        audioUrl: response.data.audioUrl,\r\n        title: response.data.title,\r\n        duration: response.data.duration,\r\n        thumbnail: response.data.thumbnail\r\n      };\r\n    }\r\n    \r\n    throw new Error('Webhook não retornou dados válidos');\r\n  } catch (error) {\r\n    console.error('Erro no processamento via webhook:', error);\r\n    throw handleApiError(error);\r\n  }\r\n};\r\n\r\n// Download file from URL - Modified for automatic download\r\nexport const downloadFromUrl = async (url, filename, isDirect = false) => {\r\n  try {\r\n    console.log('Fazendo download do arquivo:', url);\r\n    \r\n    // For direct URLs, try to download automatically first\r\n    if (isDirect) {\r\n      console.log('Tentando download automático de URL direta:', url);\r\n      try {\r\n        // Improve filename with proper extension if missing\r\n        let downloadFilename = filename || 'download';\r\n        if (!downloadFilename.includes('.')) {\r\n          // Try to detect extension from URL\r\n          const urlPath = new URL(url).pathname;\r\n          const urlExtension = urlPath.split('.').pop();\r\n          if (urlExtension && urlExtension.length <= 4) {\r\n            downloadFilename += '.' + urlExtension;\r\n          } else {\r\n            downloadFilename += '.mp4'; // Default to mp4\r\n          }\r\n        }\r\n        \r\n        // Try fetch first for better compatibility with Instagram URLs\r\n        try {\r\n          const response = await fetch(url, { mode: 'no-cors' });\r\n          if (response.type === 'opaque' || response.ok) {\r\n            // If fetch works, create download link\r\n            const link = document.createElement('a');\r\n            link.href = url;\r\n            link.download = downloadFilename;\r\n            link.target = '_blank';\r\n            link.style.display = 'none';\r\n            document.body.appendChild(link);\r\n            link.click();\r\n            document.body.removeChild(link);\r\n            return;\r\n          }\r\n        } catch (fetchError) {\r\n          console.log('Fetch falhou, tentando link direto:', fetchError);\r\n        }\r\n        \r\n        // Fallback: Create a temporary link to trigger download\r\n        const link = document.createElement('a');\r\n        link.href = url;\r\n        link.download = downloadFilename;\r\n        link.target = '_blank';\r\n        link.style.display = 'none';\r\n        document.body.appendChild(link);\r\n        link.click();\r\n        document.body.removeChild(link);\r\n        return;\r\n      } catch (directError) {\r\n        console.log('Download automático falhou, redirecionando:', directError);\r\n        window.open(url, '_blank');\r\n        return;\r\n      }\r\n    }\r\n    \r\n    const response = await axios.get(url, {\r\n      responseType: 'blob',\r\n      timeout: API_TIMEOUT * 3, // Mais tempo para download de arquivos grandes\r\n      onDownloadProgress: (progressEvent) => {\r\n        if (progressEvent.total) {\r\n          const progress = Math.round((progressEvent.loaded * 100) / progressEvent.total);\r\n          console.log(`Download progress: ${progress}%`);\r\n        }\r\n      }\r\n    });\r\n    \r\n    // Create download link\r\n    const blob = new Blob([response.data]);\r\n    const downloadUrl = window.URL.createObjectURL(blob);\r\n    const link = document.createElement('a');\r\n    link.href = downloadUrl;\r\n    link.download = filename || 'download';\r\n    document.body.appendChild(link);\r\n    link.click();\r\n    document.body.removeChild(link);\r\n    window.URL.revokeObjectURL(downloadUrl);\r\n    \r\n    return response.data;\r\n  } catch (error) {\r\n    console.error('Erro no download do arquivo:', error);\r\n    throw handleApiError(error);\r\n  }\r\n};\r\n\r\n// Process tunnel URL for transcription\r\nexport const processTunnelUrl = async (tunnelUrl) => {\r\n  try {\r\n    console.log('Processando URL do tunnel para transcrição:', tunnelUrl);\r\n    \r\n    const response = await axios.get(tunnelUrl, {\r\n      responseType: 'blob',\r\n      timeout: API_TIMEOUT * 5, // Mais tempo para arquivos grandes\r\n      onDownloadProgress: (progressEvent) => {\r\n        if (progressEvent.total) {\r\n          const progress = Math.round((progressEvent.loaded * 100) / progressEvent.total);\r\n          console.log(`Download progress: ${progress}%`);\r\n        }\r\n      }\r\n    });\r\n    \r\n    // Return blob for transcription\r\n    return response.data;\r\n  } catch (error) {\r\n    console.error('Erro ao processar URL do tunnel:', error);\r\n    throw handleApiError(error);\r\n  }\r\n};\r\n\r\n// Get direct download link for social download\r\nexport const getTunnelDownloadInfo = (videoData) => {\r\n  if ((videoData.status === 'tunnel' || videoData.status === 'redirect') && videoData.tunnelUrl) {\r\n        return {\r\n          downloadUrl: videoData.tunnelUrl,\r\n      filename: videoData.filename,\r\n      title: videoData.title\r\n    };\r\n  }\r\n  \r\n  // Fallback para estrutura antiga\r\n  return {\r\n    downloadUrl: videoData.videoUrl || videoData.audioUrl,\r\n    filename: videoData.title ? `${videoData.title}.mp4` : 'download.mp4',\r\n    title: videoData.title\r\n  };\r\n};\r\n\r\n// Webhook processing functions replace previous download methods\r\n\r\n// Transcription Functions\r\n// Função transcribeAudio removida - agora usando apenas Replicate Whisper\r\n\r\n// Utility Functions\r\n\r\nexport const validateVideoUrl = (url) => {\r\n  const patterns = {\r\n    youtube: /(?:youtube\\.com\\/(?:[^\\/]+\\/.+\\/|(?:v|e(?:mbed)?)\\/|.*[?&]v=|shorts\\/)|youtu\\.be\\/)/,\r\n    instagram: /(?:instagram\\.com\\/(?:p|reel|tv)\\/)/,\r\n    tiktok: /(?:tiktok\\.com\\/@[^\\/]+\\/video\\/|vm\\.tiktok\\.com\\/)/\r\n  };\r\n  \r\n  for (const [platform, pattern] of Object.entries(patterns)) {\r\n    if (pattern.test(url)) {\r\n      return platform;\r\n    }\r\n  }\r\n  \r\n  return null;\r\n};\r\n\r\n// File Processing\r\nexport const convertToAudio = async (videoBlob) => {\r\n  return new Promise((resolve, reject) => {\r\n    const audio = document.createElement('audio');\r\n    const url = URL.createObjectURL(videoBlob);\r\n    \r\n    audio.src = url;\r\n    audio.addEventListener('loadedmetadata', () => {\r\n      // For now, we'll return the original blob\r\n      // In a real implementation, you might want to use FFmpeg.js\r\n      resolve(videoBlob);\r\n      URL.revokeObjectURL(url);\r\n    });\r\n    \r\n    audio.addEventListener('error', () => {\r\n      reject(new Error('Erro ao processar o arquivo de áudio'));\r\n      URL.revokeObjectURL(url);\r\n    });\r\n  });\r\n};\r\n\r\n// Error Handling\r\nexport const handleApiError = (error) => {\r\n  if (error.response) {\r\n    // Server responded with error status\r\n    const status = error.response.status;\r\n    const message = error.response.data?.message || error.message;\r\n    \r\n    switch (status) {\r\n      case 401:\r\n        return 'Chave de API inválida ou expirada';\r\n      case 403:\r\n        return 'Acesso negado. Verifique suas permissões';\r\n      case 429:\r\n        return 'Limite de requisições excedido. Tente novamente mais tarde';\r\n      case 500:\r\n        return 'Erro interno do servidor';\r\n      default:\r\n        return `Erro ${status}: ${message}`;\r\n    }\r\n  } else if (error.request) {\r\n    // Network error\r\n    return 'Erro de conexão. Verifique sua internet';\r\n  } else {\r\n    // Other error\r\n    return error.message || 'Erro desconhecido';\r\n  }\r\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}