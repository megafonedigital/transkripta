{"ast":null,"code":"import config from'../config/env';/**\n * Serviço para integração com Replicate Whisper API\n * Suporta processamento assíncrono para arquivos grandes sem timeout\n */class ReplicateService{constructor(){this.baseUrl='https://api.replicate.com/v1';this.apiToken=config.replicate.apiToken;this.webhookUrl=config.replicate.webhookUrl;this.whisperModel=config.transcription.whisperModel;}/**\n   * Verifica se o serviço está configurado corretamente\n   */isConfigured(){return!!(this.apiToken&&this.webhookUrl&&this.whisperModel);}/**\n   * Cria uma predição para transcrição de áudio\n   * @param {string} audioUrl - URL do arquivo de áudio\n   * @param {Object} options - Opções adicionais\n   * @returns {Promise<Object>} - Dados da predição criada\n   */async createTranscription(audioUrl){let options=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};if(!this.isConfigured()){throw new Error('Replicate service não está configurado. Verifique as variáveis de ambiente.');}const payload={version:this.whisperModel.split(':')[1],// Extrai o version ID\ninput:{audio:audioUrl,model:'large-v3',translate:options.translate||false,language:options.language||null,temperature:options.temperature||0,transcription:options.transcription||'plain text',suppress_tokens:options.suppress_tokens||'-1',logprob_threshold:options.logprob_threshold||-1.0,no_speech_threshold:options.no_speech_threshold||0.6,condition_on_previous_text:options.condition_on_previous_text!==false,compression_ratio_threshold:options.compression_ratio_threshold||2.4,temperature_increment_on_fallback:options.temperature_increment_on_fallback||0.2},webhook:this.webhookUrl,webhook_events_filter:['start','output','logs','completed']};try{const response=await fetch(`${this.baseUrl}/predictions`,{method:'POST',headers:{'Authorization':`Bearer ${this.apiToken}`,'Content-Type':'application/json'},body:JSON.stringify(payload)});if(!response.ok){const errorData=await response.json().catch(()=>({}));throw new Error(`Erro na API Replicate: ${response.status} - ${errorData.detail||response.statusText}`);}const prediction=await response.json();// Salvar informações da predição no localStorage para acompanhamento\nthis.savePredictionInfo(prediction.id,{id:prediction.id,status:prediction.status,audioUrl,createdAt:new Date().toISOString(),model:this.whisperModel,options});return prediction;}catch(error){console.error('Erro ao criar transcrição:',error);throw error;}}/**\n   * Consulta o status de uma predição\n   * @param {string} predictionId - ID da predição\n   * @returns {Promise<Object>} - Status atual da predição\n   */async getPredictionStatus(predictionId){if(!this.isConfigured()){throw new Error('Replicate service não está configurado.');}try{const response=await fetch(`${this.baseUrl}/predictions/${predictionId}`,{headers:{'Authorization':`Bearer ${this.apiToken}`,'Content-Type':'application/json'}});if(!response.ok){const errorData=await response.json().catch(()=>({}));throw new Error(`Erro ao consultar predição: ${response.status} - ${errorData.detail||response.statusText}`);}const prediction=await response.json();// Atualizar informações salvas\nthis.updatePredictionInfo(predictionId,{status:prediction.status,output:prediction.output,error:prediction.error,logs:prediction.logs,updatedAt:new Date().toISOString()});return prediction;}catch(error){console.error('Erro ao consultar status da predição:',error);throw error;}}/**\n   * Cancela uma predição em andamento\n   * @param {string} predictionId - ID da predição\n   * @returns {Promise<Object>} - Resultado do cancelamento\n   */async cancelPrediction(predictionId){if(!this.isConfigured()){throw new Error('Replicate service não está configurado.');}try{const response=await fetch(`${this.baseUrl}/predictions/${predictionId}/cancel`,{method:'POST',headers:{'Authorization':`Bearer ${this.apiToken}`,'Content-Type':'application/json'}});if(!response.ok){const errorData=await response.json().catch(()=>({}));throw new Error(`Erro ao cancelar predição: ${response.status} - ${errorData.detail||response.statusText}`);}const result=await response.json();// Atualizar status local\nthis.updatePredictionInfo(predictionId,{status:'canceled',updatedAt:new Date().toISOString()});return result;}catch(error){console.error('Erro ao cancelar predição:',error);throw error;}}/**\n   * Salva informações da predição no localStorage\n   * @param {string} predictionId - ID da predição\n   * @param {Object} info - Informações da predição\n   */savePredictionInfo(predictionId,info){try{const predictions=this.getAllPredictions();predictions[predictionId]=info;localStorage.setItem('replicate_predictions',JSON.stringify(predictions));}catch(error){console.warn('Erro ao salvar informações da predição:',error);}}/**\n   * Atualiza informações da predição no localStorage\n   * @param {string} predictionId - ID da predição\n   * @param {Object} updates - Atualizações\n   */updatePredictionInfo(predictionId,updates){try{const predictions=this.getAllPredictions();if(predictions[predictionId]){predictions[predictionId]={...predictions[predictionId],...updates};localStorage.setItem('replicate_predictions',JSON.stringify(predictions));}}catch(error){console.warn('Erro ao atualizar informações da predição:',error);}}/**\n   * Obtém informações de uma predição específica\n   * @param {string} predictionId - ID da predição\n   * @returns {Object|null} - Informações da predição\n   */getPredictionInfo(predictionId){try{const predictions=this.getAllPredictions();return predictions[predictionId]||null;}catch(error){console.warn('Erro ao obter informações da predição:',error);return null;}}/**\n   * Obtém todas as predições salvas\n   * @returns {Object} - Todas as predições\n   */getAllPredictions(){try{const stored=localStorage.getItem('replicate_predictions');return stored?JSON.parse(stored):{};}catch(error){console.warn('Erro ao obter predições:',error);return{};}}/**\n   * Remove predições antigas (mais de 7 dias)\n   */cleanupOldPredictions(){try{const predictions=this.getAllPredictions();const sevenDaysAgo=new Date(Date.now()-7*24*60*60*1000);Object.keys(predictions).forEach(id=>{const prediction=predictions[id];const createdAt=new Date(prediction.createdAt);if(createdAt<sevenDaysAgo){delete predictions[id];}});localStorage.setItem('replicate_predictions',JSON.stringify(predictions));}catch(error){console.warn('Erro ao limpar predições antigas:',error);}}/**\n   * Obtém predições ativas (em processamento)\n   * @returns {Array} - Lista de predições ativas\n   */getActivePredictions(){try{const predictions=this.getAllPredictions();return Object.values(predictions).filter(p=>['starting','processing'].includes(p.status));}catch(error){console.warn('Erro ao obter predições ativas:',error);return[];}}}// Instância singleton\nconst replicateService=new ReplicateService();// Limpar predições antigas na inicialização\nreplicateService.cleanupOldPredictions();export default replicateService;","map":{"version":3,"names":["config","ReplicateService","constructor","baseUrl","apiToken","replicate","webhookUrl","whisperModel","transcription","isConfigured","createTranscription","audioUrl","options","arguments","length","undefined","Error","payload","version","split","input","audio","model","translate","language","temperature","suppress_tokens","logprob_threshold","no_speech_threshold","condition_on_previous_text","compression_ratio_threshold","temperature_increment_on_fallback","webhook","webhook_events_filter","response","fetch","method","headers","body","JSON","stringify","ok","errorData","json","catch","status","detail","statusText","prediction","savePredictionInfo","id","createdAt","Date","toISOString","error","console","getPredictionStatus","predictionId","updatePredictionInfo","output","logs","updatedAt","cancelPrediction","result","info","predictions","getAllPredictions","localStorage","setItem","warn","updates","getPredictionInfo","stored","getItem","parse","cleanupOldPredictions","sevenDaysAgo","now","Object","keys","forEach","getActivePredictions","values","filter","p","includes","replicateService"],"sources":["C:/Users/Afonso/Desktop/Transkipta/src/services/replicateService.js"],"sourcesContent":["import config from '../config/env';\n\n/**\n * Serviço para integração com Replicate Whisper API\n * Suporta processamento assíncrono para arquivos grandes sem timeout\n */\nclass ReplicateService {\n  constructor() {\n    this.baseUrl = 'https://api.replicate.com/v1';\n    this.apiToken = config.replicate.apiToken;\n    this.webhookUrl = config.replicate.webhookUrl;\n    this.whisperModel = config.transcription.whisperModel;\n  }\n\n  /**\n   * Verifica se o serviço está configurado corretamente\n   */\n  isConfigured() {\n    return !!(this.apiToken && this.webhookUrl && this.whisperModel);\n  }\n\n  /**\n   * Cria uma predição para transcrição de áudio\n   * @param {string} audioUrl - URL do arquivo de áudio\n   * @param {Object} options - Opções adicionais\n   * @returns {Promise<Object>} - Dados da predição criada\n   */\n  async createTranscription(audioUrl, options = {}) {\n    if (!this.isConfigured()) {\n      throw new Error('Replicate service não está configurado. Verifique as variáveis de ambiente.');\n    }\n\n    const payload = {\n      version: this.whisperModel.split(':')[1], // Extrai o version ID\n      input: {\n        audio: audioUrl,\n        model: 'large-v3',\n        translate: options.translate || false,\n        language: options.language || null,\n        temperature: options.temperature || 0,\n        transcription: options.transcription || 'plain text',\n        suppress_tokens: options.suppress_tokens || '-1',\n        logprob_threshold: options.logprob_threshold || -1.0,\n        no_speech_threshold: options.no_speech_threshold || 0.6,\n        condition_on_previous_text: options.condition_on_previous_text !== false,\n        compression_ratio_threshold: options.compression_ratio_threshold || 2.4,\n        temperature_increment_on_fallback: options.temperature_increment_on_fallback || 0.2\n      },\n      webhook: this.webhookUrl,\n      webhook_events_filter: ['start', 'output', 'logs', 'completed']\n    };\n\n    try {\n      const response = await fetch(`${this.baseUrl}/predictions`, {\n        method: 'POST',\n        headers: {\n          'Authorization': `Bearer ${this.apiToken}`,\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify(payload)\n      });\n\n      if (!response.ok) {\n        const errorData = await response.json().catch(() => ({}));\n        throw new Error(`Erro na API Replicate: ${response.status} - ${errorData.detail || response.statusText}`);\n      }\n\n      const prediction = await response.json();\n      \n      // Salvar informações da predição no localStorage para acompanhamento\n      this.savePredictionInfo(prediction.id, {\n        id: prediction.id,\n        status: prediction.status,\n        audioUrl,\n        createdAt: new Date().toISOString(),\n        model: this.whisperModel,\n        options\n      });\n\n      return prediction;\n    } catch (error) {\n      console.error('Erro ao criar transcrição:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Consulta o status de uma predição\n   * @param {string} predictionId - ID da predição\n   * @returns {Promise<Object>} - Status atual da predição\n   */\n  async getPredictionStatus(predictionId) {\n    if (!this.isConfigured()) {\n      throw new Error('Replicate service não está configurado.');\n    }\n\n    try {\n      const response = await fetch(`${this.baseUrl}/predictions/${predictionId}`, {\n        headers: {\n          'Authorization': `Bearer ${this.apiToken}`,\n          'Content-Type': 'application/json',\n        }\n      });\n\n      if (!response.ok) {\n        const errorData = await response.json().catch(() => ({}));\n        throw new Error(`Erro ao consultar predição: ${response.status} - ${errorData.detail || response.statusText}`);\n      }\n\n      const prediction = await response.json();\n      \n      // Atualizar informações salvas\n      this.updatePredictionInfo(predictionId, {\n        status: prediction.status,\n        output: prediction.output,\n        error: prediction.error,\n        logs: prediction.logs,\n        updatedAt: new Date().toISOString()\n      });\n\n      return prediction;\n    } catch (error) {\n      console.error('Erro ao consultar status da predição:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Cancela uma predição em andamento\n   * @param {string} predictionId - ID da predição\n   * @returns {Promise<Object>} - Resultado do cancelamento\n   */\n  async cancelPrediction(predictionId) {\n    if (!this.isConfigured()) {\n      throw new Error('Replicate service não está configurado.');\n    }\n\n    try {\n      const response = await fetch(`${this.baseUrl}/predictions/${predictionId}/cancel`, {\n        method: 'POST',\n        headers: {\n          'Authorization': `Bearer ${this.apiToken}`,\n          'Content-Type': 'application/json',\n        }\n      });\n\n      if (!response.ok) {\n        const errorData = await response.json().catch(() => ({}));\n        throw new Error(`Erro ao cancelar predição: ${response.status} - ${errorData.detail || response.statusText}`);\n      }\n\n      const result = await response.json();\n      \n      // Atualizar status local\n      this.updatePredictionInfo(predictionId, {\n        status: 'canceled',\n        updatedAt: new Date().toISOString()\n      });\n\n      return result;\n    } catch (error) {\n      console.error('Erro ao cancelar predição:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Salva informações da predição no localStorage\n   * @param {string} predictionId - ID da predição\n   * @param {Object} info - Informações da predição\n   */\n  savePredictionInfo(predictionId, info) {\n    try {\n      const predictions = this.getAllPredictions();\n      predictions[predictionId] = info;\n      localStorage.setItem('replicate_predictions', JSON.stringify(predictions));\n    } catch (error) {\n      console.warn('Erro ao salvar informações da predição:', error);\n    }\n  }\n\n  /**\n   * Atualiza informações da predição no localStorage\n   * @param {string} predictionId - ID da predição\n   * @param {Object} updates - Atualizações\n   */\n  updatePredictionInfo(predictionId, updates) {\n    try {\n      const predictions = this.getAllPredictions();\n      if (predictions[predictionId]) {\n        predictions[predictionId] = { ...predictions[predictionId], ...updates };\n        localStorage.setItem('replicate_predictions', JSON.stringify(predictions));\n      }\n    } catch (error) {\n      console.warn('Erro ao atualizar informações da predição:', error);\n    }\n  }\n\n  /**\n   * Obtém informações de uma predição específica\n   * @param {string} predictionId - ID da predição\n   * @returns {Object|null} - Informações da predição\n   */\n  getPredictionInfo(predictionId) {\n    try {\n      const predictions = this.getAllPredictions();\n      return predictions[predictionId] || null;\n    } catch (error) {\n      console.warn('Erro ao obter informações da predição:', error);\n      return null;\n    }\n  }\n\n  /**\n   * Obtém todas as predições salvas\n   * @returns {Object} - Todas as predições\n   */\n  getAllPredictions() {\n    try {\n      const stored = localStorage.getItem('replicate_predictions');\n      return stored ? JSON.parse(stored) : {};\n    } catch (error) {\n      console.warn('Erro ao obter predições:', error);\n      return {};\n    }\n  }\n\n  /**\n   * Remove predições antigas (mais de 7 dias)\n   */\n  cleanupOldPredictions() {\n    try {\n      const predictions = this.getAllPredictions();\n      const sevenDaysAgo = new Date(Date.now() - 7 * 24 * 60 * 60 * 1000);\n      \n      Object.keys(predictions).forEach(id => {\n        const prediction = predictions[id];\n        const createdAt = new Date(prediction.createdAt);\n        \n        if (createdAt < sevenDaysAgo) {\n          delete predictions[id];\n        }\n      });\n      \n      localStorage.setItem('replicate_predictions', JSON.stringify(predictions));\n    } catch (error) {\n      console.warn('Erro ao limpar predições antigas:', error);\n    }\n  }\n\n  /**\n   * Obtém predições ativas (em processamento)\n   * @returns {Array} - Lista de predições ativas\n   */\n  getActivePredictions() {\n    try {\n      const predictions = this.getAllPredictions();\n      return Object.values(predictions).filter(p => \n        ['starting', 'processing'].includes(p.status)\n      );\n    } catch (error) {\n      console.warn('Erro ao obter predições ativas:', error);\n      return [];\n    }\n  }\n}\n\n// Instância singleton\nconst replicateService = new ReplicateService();\n\n// Limpar predições antigas na inicialização\nreplicateService.cleanupOldPredictions();\n\nexport default replicateService;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}