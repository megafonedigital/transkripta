{"ast":null,"code":"import axios from 'axios';\nimport config from '../config/env';\n\n// Configurações das APIs\nconst OPENAI_API_KEY = config.openai.apiKey;\nconst OPENAI_API_URL = config.openai.baseUrl;\nconst RAPIDAPI_KEY = config.rapidapi.key;\nconst RAPIDAPI_HOST = config.rapidapi.host;\nconst COBALT_API_URL = config.cobalt.apiUrl;\nconst API_TIMEOUT = config.api.timeout;\n\n// Create axios instances\nconst openaiApi = axios.create({\n  baseURL: OPENAI_API_URL,\n  timeout: API_TIMEOUT,\n  headers: {\n    'Authorization': `Bearer ${OPENAI_API_KEY}`,\n    'Content-Type': 'application/json'\n  }\n});\nconst rapidApi = axios.create({\n  timeout: API_TIMEOUT,\n  headers: {\n    'X-RapidAPI-Key': RAPIDAPI_KEY,\n    'X-RapidAPI-Host': RAPIDAPI_HOST\n  }\n});\nconst cobaltApi = axios.create({\n  baseURL: COBALT_API_URL,\n  timeout: API_TIMEOUT,\n  headers: {\n    'Content-Type': 'application/json',\n    'Accept': 'application/json'\n  }\n});\n\n// Video Download Functions\nexport const downloadVideo = async (url, platform) => {\n  try {\n    let downloadUrl;\n\n    // Priorizar Cobalt como serviço principal\n    try {\n      console.log('Tentando download via Cobalt...');\n      downloadUrl = await downloadFromCobalt(url);\n    } catch (cobaltError) {\n      console.warn('Falha no Cobalt, tentando alternativas:', cobaltError.message);\n\n      // Fallback para RapidAPI apenas para YouTube\n      if (platform === 'youtube') {\n        try {\n          console.log('Tentando download via RapidAPI...');\n          downloadUrl = await downloadFromYoutube(url);\n        } catch (rapidError) {\n          console.error('Falha no RapidAPI:', rapidError.message);\n          throw new Error('Todos os serviços de download falharam');\n        }\n      } else {\n        throw cobaltError;\n      }\n    }\n    if (!downloadUrl) {\n      throw new Error('Não foi possível obter URL de download');\n    }\n    console.log('URL de download obtida:', downloadUrl);\n\n    // Download the actual file\n    const response = await axios.get(downloadUrl, {\n      responseType: 'blob',\n      timeout: API_TIMEOUT * 2,\n      // Mais tempo para download de arquivos grandes\n      onDownloadProgress: progressEvent => {\n        if (progressEvent.total) {\n          const progress = Math.round(progressEvent.loaded * 100 / progressEvent.total);\n          console.log(`Download progress: ${progress}%`);\n        }\n      }\n    });\n    return response.data;\n  } catch (error) {\n    console.error('Erro no download do vídeo:', error);\n    throw handleApiError(error);\n  }\n};\nconst downloadFromYoutube = async url => {\n  try {\n    const response = await rapidApi.get('/dl', {\n      params: {\n        id: extractVideoId(url)\n      }\n    });\n    if (response.data && response.data.link) {\n      return response.data.link;\n    }\n    throw new Error('URL de download não encontrada');\n  } catch (error) {\n    throw new Error(`Erro no download do YouTube: ${error.message}`);\n  }\n};\nconst downloadFromCobalt = async url => {\n  try {\n    const response = await cobaltApi.post('', {\n      url: url,\n      vCodec: 'h264',\n      vQuality: '720',\n      aFormat: 'mp3',\n      isAudioOnly: false\n    });\n    if (response.data && response.data.url) {\n      return response.data.url;\n    }\n    throw new Error('URL de download não encontrada');\n  } catch (error) {\n    throw new Error(`Erro no download via Cobalt: ${error.message}`);\n  }\n};\n\n// Transcription Functions\nexport const transcribeAudio = async (audioFile, options = {}) => {\n  try {\n    const formData = new FormData();\n    formData.append('file', audioFile);\n    formData.append('model', options.model || 'whisper-1');\n    if (options.language) {\n      formData.append('language', options.language);\n    }\n    if (options.prompt) {\n      formData.append('prompt', options.prompt);\n    }\n    const response = await openaiApi.post('/audio/transcriptions', formData, {\n      headers: {\n        'Content-Type': 'multipart/form-data'\n      }\n    });\n    return {\n      text: response.data.text,\n      language: response.data.language || options.language,\n      duration: response.data.duration\n    };\n  } catch (error) {\n    console.error('Erro na transcrição:', error);\n    throw new Error(`Falha na transcrição: ${error.message}`);\n  }\n};\n\n// Utility Functions\nconst extractVideoId = url => {\n  const regex = /(?:youtube\\.com\\/(?:[^\\/]+\\/.+\\/|(?:v|e(?:mbed)?)\\/|.*[?&]v=)|youtu\\.be\\/)([^\"&?\\/\\s]{11})/;\n  const match = url.match(regex);\n  return match ? match[1] : null;\n};\nexport const validateVideoUrl = url => {\n  const patterns = {\n    youtube: /(?:youtube\\.com\\/(?:[^\\/]+\\/.+\\/|(?:v|e(?:mbed)?)\\/|.*[?&]v=)|youtu\\.be\\/)/,\n    instagram: /(?:instagram\\.com\\/(?:p|reel|tv)\\/)/,\n    tiktok: /(?:tiktok\\.com\\/@[^\\/]+\\/video\\/|vm\\.tiktok\\.com\\/)/\n  };\n  for (const [platform, pattern] of Object.entries(patterns)) {\n    if (pattern.test(url)) {\n      return platform;\n    }\n  }\n  return null;\n};\n\n// File Processing\nexport const convertToAudio = async videoBlob => {\n  return new Promise((resolve, reject) => {\n    const audio = document.createElement('audio');\n    const url = URL.createObjectURL(videoBlob);\n    audio.src = url;\n    audio.addEventListener('loadedmetadata', () => {\n      // For now, we'll return the original blob\n      // In a real implementation, you might want to use FFmpeg.js\n      resolve(videoBlob);\n      URL.revokeObjectURL(url);\n    });\n    audio.addEventListener('error', () => {\n      reject(new Error('Erro ao processar o arquivo de áudio'));\n      URL.revokeObjectURL(url);\n    });\n  });\n};\n\n// Error Handling\nexport const handleApiError = error => {\n  if (error.response) {\n    var _error$response$data;\n    // Server responded with error status\n    const status = error.response.status;\n    const message = ((_error$response$data = error.response.data) === null || _error$response$data === void 0 ? void 0 : _error$response$data.message) || error.message;\n    switch (status) {\n      case 401:\n        return 'Chave de API inválida ou expirada';\n      case 403:\n        return 'Acesso negado. Verifique suas permissões';\n      case 429:\n        return 'Limite de requisições excedido. Tente novamente mais tarde';\n      case 500:\n        return 'Erro interno do servidor';\n      default:\n        return `Erro ${status}: ${message}`;\n    }\n  } else if (error.request) {\n    // Network error\n    return 'Erro de conexão. Verifique sua internet';\n  } else {\n    // Other error\n    return error.message || 'Erro desconhecido';\n  }\n};","map":{"version":3,"names":["axios","config","OPENAI_API_KEY","openai","apiKey","OPENAI_API_URL","baseUrl","RAPIDAPI_KEY","rapidapi","key","RAPIDAPI_HOST","host","COBALT_API_URL","cobalt","apiUrl","API_TIMEOUT","api","timeout","openaiApi","create","baseURL","headers","rapidApi","cobaltApi","downloadVideo","url","platform","downloadUrl","console","log","downloadFromCobalt","cobaltError","warn","message","downloadFromYoutube","rapidError","error","Error","response","get","responseType","onDownloadProgress","progressEvent","total","progress","Math","round","loaded","data","handleApiError","params","id","extractVideoId","link","post","vCodec","vQuality","aFormat","isAudioOnly","transcribeAudio","audioFile","options","formData","FormData","append","model","language","prompt","text","duration","regex","match","validateVideoUrl","patterns","youtube","instagram","tiktok","pattern","Object","entries","test","convertToAudio","videoBlob","Promise","resolve","reject","audio","document","createElement","URL","createObjectURL","src","addEventListener","revokeObjectURL","_error$response$data","status","request"],"sources":["C:/Users/Afonso/Desktop/Transkipta/frontend/src/services/apiService.js"],"sourcesContent":["import axios from 'axios';\nimport config from '../config/env';\n\n// Configurações das APIs\nconst OPENAI_API_KEY = config.openai.apiKey;\nconst OPENAI_API_URL = config.openai.baseUrl;\nconst RAPIDAPI_KEY = config.rapidapi.key;\nconst RAPIDAPI_HOST = config.rapidapi.host;\nconst COBALT_API_URL = config.cobalt.apiUrl;\nconst API_TIMEOUT = config.api.timeout;\n\n// Create axios instances\nconst openaiApi = axios.create({\n  baseURL: OPENAI_API_URL,\n  timeout: API_TIMEOUT,\n  headers: {\n    'Authorization': `Bearer ${OPENAI_API_KEY}`,\n    'Content-Type': 'application/json'\n  }\n});\n\nconst rapidApi = axios.create({\n  timeout: API_TIMEOUT,\n  headers: {\n    'X-RapidAPI-Key': RAPIDAPI_KEY,\n    'X-RapidAPI-Host': RAPIDAPI_HOST\n  }\n});\n\nconst cobaltApi = axios.create({\n  baseURL: COBALT_API_URL,\n  timeout: API_TIMEOUT,\n  headers: {\n    'Content-Type': 'application/json',\n    'Accept': 'application/json'\n  }\n});\n\n// Video Download Functions\nexport const downloadVideo = async (url, platform) => {\n  try {\n    let downloadUrl;\n    \n    // Priorizar Cobalt como serviço principal\n    try {\n      console.log('Tentando download via Cobalt...');\n      downloadUrl = await downloadFromCobalt(url);\n    } catch (cobaltError) {\n      console.warn('Falha no Cobalt, tentando alternativas:', cobaltError.message);\n      \n      // Fallback para RapidAPI apenas para YouTube\n      if (platform === 'youtube') {\n        try {\n          console.log('Tentando download via RapidAPI...');\n          downloadUrl = await downloadFromYoutube(url);\n        } catch (rapidError) {\n          console.error('Falha no RapidAPI:', rapidError.message);\n          throw new Error('Todos os serviços de download falharam');\n        }\n      } else {\n        throw cobaltError;\n      }\n    }\n    \n    if (!downloadUrl) {\n      throw new Error('Não foi possível obter URL de download');\n    }\n    \n    console.log('URL de download obtida:', downloadUrl);\n    \n    // Download the actual file\n    const response = await axios.get(downloadUrl, {\n      responseType: 'blob',\n      timeout: API_TIMEOUT * 2, // Mais tempo para download de arquivos grandes\n      onDownloadProgress: (progressEvent) => {\n        if (progressEvent.total) {\n          const progress = Math.round((progressEvent.loaded * 100) / progressEvent.total);\n          console.log(`Download progress: ${progress}%`);\n        }\n      }\n    });\n    \n    return response.data;\n  } catch (error) {\n    console.error('Erro no download do vídeo:', error);\n    throw handleApiError(error);\n  }\n};\n\nconst downloadFromYoutube = async (url) => {\n  try {\n    const response = await rapidApi.get('/dl', {\n      params: {\n        id: extractVideoId(url)\n      }\n    });\n    \n    if (response.data && response.data.link) {\n      return response.data.link;\n    }\n    throw new Error('URL de download não encontrada');\n  } catch (error) {\n    throw new Error(`Erro no download do YouTube: ${error.message}`);\n  }\n};\n\nconst downloadFromCobalt = async (url) => {\n  try {\n    const response = await cobaltApi.post('', {\n      url: url,\n      vCodec: 'h264',\n      vQuality: '720',\n      aFormat: 'mp3',\n      isAudioOnly: false\n    });\n    \n    if (response.data && response.data.url) {\n      return response.data.url;\n    }\n    throw new Error('URL de download não encontrada');\n  } catch (error) {\n    throw new Error(`Erro no download via Cobalt: ${error.message}`);\n  }\n};\n\n// Transcription Functions\nexport const transcribeAudio = async (audioFile, options = {}) => {\n  try {\n    const formData = new FormData();\n    formData.append('file', audioFile);\n    formData.append('model', options.model || 'whisper-1');\n    \n    if (options.language) {\n      formData.append('language', options.language);\n    }\n    \n    if (options.prompt) {\n      formData.append('prompt', options.prompt);\n    }\n    \n    const response = await openaiApi.post('/audio/transcriptions', formData, {\n      headers: {\n        'Content-Type': 'multipart/form-data'\n      }\n    });\n    \n    return {\n      text: response.data.text,\n      language: response.data.language || options.language,\n      duration: response.data.duration\n    };\n  } catch (error) {\n    console.error('Erro na transcrição:', error);\n    throw new Error(`Falha na transcrição: ${error.message}`);\n  }\n};\n\n// Utility Functions\nconst extractVideoId = (url) => {\n  const regex = /(?:youtube\\.com\\/(?:[^\\/]+\\/.+\\/|(?:v|e(?:mbed)?)\\/|.*[?&]v=)|youtu\\.be\\/)([^\"&?\\/\\s]{11})/;\n  const match = url.match(regex);\n  return match ? match[1] : null;\n};\n\nexport const validateVideoUrl = (url) => {\n  const patterns = {\n    youtube: /(?:youtube\\.com\\/(?:[^\\/]+\\/.+\\/|(?:v|e(?:mbed)?)\\/|.*[?&]v=)|youtu\\.be\\/)/,\n    instagram: /(?:instagram\\.com\\/(?:p|reel|tv)\\/)/,\n    tiktok: /(?:tiktok\\.com\\/@[^\\/]+\\/video\\/|vm\\.tiktok\\.com\\/)/\n  };\n  \n  for (const [platform, pattern] of Object.entries(patterns)) {\n    if (pattern.test(url)) {\n      return platform;\n    }\n  }\n  \n  return null;\n};\n\n// File Processing\nexport const convertToAudio = async (videoBlob) => {\n  return new Promise((resolve, reject) => {\n    const audio = document.createElement('audio');\n    const url = URL.createObjectURL(videoBlob);\n    \n    audio.src = url;\n    audio.addEventListener('loadedmetadata', () => {\n      // For now, we'll return the original blob\n      // In a real implementation, you might want to use FFmpeg.js\n      resolve(videoBlob);\n      URL.revokeObjectURL(url);\n    });\n    \n    audio.addEventListener('error', () => {\n      reject(new Error('Erro ao processar o arquivo de áudio'));\n      URL.revokeObjectURL(url);\n    });\n  });\n};\n\n// Error Handling\nexport const handleApiError = (error) => {\n  if (error.response) {\n    // Server responded with error status\n    const status = error.response.status;\n    const message = error.response.data?.message || error.message;\n    \n    switch (status) {\n      case 401:\n        return 'Chave de API inválida ou expirada';\n      case 403:\n        return 'Acesso negado. Verifique suas permissões';\n      case 429:\n        return 'Limite de requisições excedido. Tente novamente mais tarde';\n      case 500:\n        return 'Erro interno do servidor';\n      default:\n        return `Erro ${status}: ${message}`;\n    }\n  } else if (error.request) {\n    // Network error\n    return 'Erro de conexão. Verifique sua internet';\n  } else {\n    // Other error\n    return error.message || 'Erro desconhecido';\n  }\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}