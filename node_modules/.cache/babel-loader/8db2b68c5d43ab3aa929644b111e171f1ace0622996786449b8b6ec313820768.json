{"ast":null,"code":"import config from '../config/env';\n\n/**\n * Serviço para integração com Replicate Whisper API\n * Suporta processamento assíncrono para arquivos grandes sem timeout\n */\nclass ReplicateService {\n  constructor() {\n    this.baseUrl = 'https://api.replicate.com/v1';\n    this.apiToken = config.replicate.apiToken;\n    this.webhookUrl = config.replicate.webhookUrl;\n    this.whisperModel = config.transcription.whisperModel;\n  }\n\n  /**\n   * Verifica se o serviço está configurado corretamente\n   */\n  isConfigured() {\n    return !!(this.apiToken && this.webhookUrl && this.whisperModel);\n  }\n\n  /**\n   * Cria uma predição para transcrição de áudio\n   * @param {string} audioUrl - URL do arquivo de áudio\n   * @param {Object} options - Opções adicionais\n   * @returns {Promise<Object>} - Dados da predição criada\n   */\n  async createTranscription(audioUrl, options = {}) {\n    if (!this.isConfigured()) {\n      throw new Error('Replicate service não está configurado. Verifique as variáveis de ambiente.');\n    }\n    const payload = {\n      version: this.whisperModel.split(':')[1],\n      // Extrai o version ID\n      input: {\n        audio: audioUrl,\n        model: 'large-v3',\n        translate: options.translate || false,\n        language: options.language || null,\n        temperature: options.temperature || 0,\n        transcription: options.transcription || 'plain text',\n        suppress_tokens: options.suppress_tokens || '-1',\n        logprob_threshold: options.logprob_threshold || -1.0,\n        no_speech_threshold: options.no_speech_threshold || 0.6,\n        condition_on_previous_text: options.condition_on_previous_text !== false,\n        compression_ratio_threshold: options.compression_ratio_threshold || 2.4,\n        temperature_increment_on_fallback: options.temperature_increment_on_fallback || 0.2\n      },\n      webhook: this.webhookUrl,\n      webhook_events_filter: ['start', 'output', 'logs', 'completed']\n    };\n    try {\n      const response = await fetch(`${this.baseUrl}/predictions`, {\n        method: 'POST',\n        headers: {\n          'Authorization': `Bearer ${this.apiToken}`,\n          'Content-Type': 'application/json'\n        },\n        body: JSON.stringify(payload)\n      });\n      if (!response.ok) {\n        const errorData = await response.json().catch(() => ({}));\n        throw new Error(`Erro na API Replicate: ${response.status} - ${errorData.detail || response.statusText}`);\n      }\n      const prediction = await response.json();\n\n      // Salvar informações da predição no localStorage para acompanhamento\n      this.savePredictionInfo(prediction.id, {\n        id: prediction.id,\n        status: prediction.status,\n        audioUrl,\n        createdAt: new Date().toISOString(),\n        model: this.whisperModel,\n        options\n      });\n      return prediction;\n    } catch (error) {\n      console.error('Erro ao criar transcrição:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Consulta o status de uma predição\n   * @param {string} predictionId - ID da predição\n   * @returns {Promise<Object>} - Status atual da predição\n   */\n  async getPredictionStatus(predictionId) {\n    if (!this.isConfigured()) {\n      throw new Error('Replicate service não está configurado.');\n    }\n    try {\n      const response = await fetch(`${this.baseUrl}/predictions/${predictionId}`, {\n        headers: {\n          'Authorization': `Bearer ${this.apiToken}`,\n          'Content-Type': 'application/json'\n        }\n      });\n      if (!response.ok) {\n        const errorData = await response.json().catch(() => ({}));\n        throw new Error(`Erro ao consultar predição: ${response.status} - ${errorData.detail || response.statusText}`);\n      }\n      const prediction = await response.json();\n\n      // Atualizar informações salvas\n      this.updatePredictionInfo(predictionId, {\n        status: prediction.status,\n        output: prediction.output,\n        error: prediction.error,\n        logs: prediction.logs,\n        updatedAt: new Date().toISOString()\n      });\n      return prediction;\n    } catch (error) {\n      console.error('Erro ao consultar status da predição:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Cancela uma predição em andamento\n   * @param {string} predictionId - ID da predição\n   * @returns {Promise<Object>} - Resultado do cancelamento\n   */\n  async cancelPrediction(predictionId) {\n    if (!this.isConfigured()) {\n      throw new Error('Replicate service não está configurado.');\n    }\n    try {\n      const response = await fetch(`${this.baseUrl}/predictions/${predictionId}/cancel`, {\n        method: 'POST',\n        headers: {\n          'Authorization': `Bearer ${this.apiToken}`,\n          'Content-Type': 'application/json'\n        }\n      });\n      if (!response.ok) {\n        const errorData = await response.json().catch(() => ({}));\n        throw new Error(`Erro ao cancelar predição: ${response.status} - ${errorData.detail || response.statusText}`);\n      }\n      const result = await response.json();\n\n      // Atualizar status local\n      this.updatePredictionInfo(predictionId, {\n        status: 'canceled',\n        updatedAt: new Date().toISOString()\n      });\n      return result;\n    } catch (error) {\n      console.error('Erro ao cancelar predição:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Salva informações da predição no localStorage\n   * @param {string} predictionId - ID da predição\n   * @param {Object} info - Informações da predição\n   */\n  savePredictionInfo(predictionId, info) {\n    try {\n      const predictions = this.getAllPredictions();\n      predictions[predictionId] = info;\n      localStorage.setItem('replicate_predictions', JSON.stringify(predictions));\n    } catch (error) {\n      console.warn('Erro ao salvar informações da predição:', error);\n    }\n  }\n\n  /**\n   * Atualiza informações da predição no localStorage\n   * @param {string} predictionId - ID da predição\n   * @param {Object} updates - Atualizações\n   */\n  updatePredictionInfo(predictionId, updates) {\n    try {\n      const predictions = this.getAllPredictions();\n      if (predictions[predictionId]) {\n        predictions[predictionId] = {\n          ...predictions[predictionId],\n          ...updates\n        };\n        localStorage.setItem('replicate_predictions', JSON.stringify(predictions));\n      }\n    } catch (error) {\n      console.warn('Erro ao atualizar informações da predição:', error);\n    }\n  }\n\n  /**\n   * Obtém informações de uma predição específica\n   * @param {string} predictionId - ID da predição\n   * @returns {Object|null} - Informações da predição\n   */\n  getPredictionInfo(predictionId) {\n    try {\n      const predictions = this.getAllPredictions();\n      return predictions[predictionId] || null;\n    } catch (error) {\n      console.warn('Erro ao obter informações da predição:', error);\n      return null;\n    }\n  }\n\n  /**\n   * Obtém todas as predições salvas\n   * @returns {Object} - Todas as predições\n   */\n  getAllPredictions() {\n    try {\n      const stored = localStorage.getItem('replicate_predictions');\n      return stored ? JSON.parse(stored) : {};\n    } catch (error) {\n      console.warn('Erro ao obter predições:', error);\n      return {};\n    }\n  }\n\n  /**\n   * Remove predições antigas (mais de 7 dias)\n   */\n  cleanupOldPredictions() {\n    try {\n      const predictions = this.getAllPredictions();\n      const sevenDaysAgo = new Date(Date.now() - 7 * 24 * 60 * 60 * 1000);\n      Object.keys(predictions).forEach(id => {\n        const prediction = predictions[id];\n        const createdAt = new Date(prediction.createdAt);\n        if (createdAt < sevenDaysAgo) {\n          delete predictions[id];\n        }\n      });\n      localStorage.setItem('replicate_predictions', JSON.stringify(predictions));\n    } catch (error) {\n      console.warn('Erro ao limpar predições antigas:', error);\n    }\n  }\n\n  /**\n   * Obtém todas as predições do localStorage\n   * @returns {Object} - Objeto com todas as predições\n   */\n  getPredictions() {\n    try {\n      return this.getAllPredictions();\n    } catch (error) {\n      console.warn('Erro ao obter predições:', error);\n      return {};\n    }\n  }\n\n  /**\n   * Obtém predições ativas (em processamento)\n   * @returns {Array} - Lista de predições ativas\n   */\n  getActivePredictions() {\n    try {\n      const predictions = this.getAllPredictions();\n      return Object.values(predictions).filter(p => ['starting', 'processing'].includes(p.status));\n    } catch (error) {\n      console.warn('Erro ao obter predições ativas:', error);\n      return [];\n    }\n  }\n}\n\n// Instância singleton\nconst replicateService = new ReplicateService();\n\n// Limpar predições antigas na inicialização\nreplicateService.cleanupOldPredictions();\nexport default replicateService;","map":{"version":3,"names":["config","ReplicateService","constructor","baseUrl","apiToken","replicate","webhookUrl","whisperModel","transcription","isConfigured","createTranscription","audioUrl","options","Error","payload","version","split","input","audio","model","translate","language","temperature","suppress_tokens","logprob_threshold","no_speech_threshold","condition_on_previous_text","compression_ratio_threshold","temperature_increment_on_fallback","webhook","webhook_events_filter","response","fetch","method","headers","body","JSON","stringify","ok","errorData","json","catch","status","detail","statusText","prediction","savePredictionInfo","id","createdAt","Date","toISOString","error","console","getPredictionStatus","predictionId","updatePredictionInfo","output","logs","updatedAt","cancelPrediction","result","info","predictions","getAllPredictions","localStorage","setItem","warn","updates","getPredictionInfo","stored","getItem","parse","cleanupOldPredictions","sevenDaysAgo","now","Object","keys","forEach","getPredictions","getActivePredictions","values","filter","p","includes","replicateService"],"sources":["C:/Users/Afonso/Desktop/Transkipta/src/services/replicateService.js"],"sourcesContent":["import config from '../config/env';\n\n/**\n * Serviço para integração com Replicate Whisper API\n * Suporta processamento assíncrono para arquivos grandes sem timeout\n */\nclass ReplicateService {\n  constructor() {\n    this.baseUrl = 'https://api.replicate.com/v1';\n    this.apiToken = config.replicate.apiToken;\n    this.webhookUrl = config.replicate.webhookUrl;\n    this.whisperModel = config.transcription.whisperModel;\n  }\n\n  /**\n   * Verifica se o serviço está configurado corretamente\n   */\n  isConfigured() {\n    return !!(this.apiToken && this.webhookUrl && this.whisperModel);\n  }\n\n  /**\n   * Cria uma predição para transcrição de áudio\n   * @param {string} audioUrl - URL do arquivo de áudio\n   * @param {Object} options - Opções adicionais\n   * @returns {Promise<Object>} - Dados da predição criada\n   */\n  async createTranscription(audioUrl, options = {}) {\n    if (!this.isConfigured()) {\n      throw new Error('Replicate service não está configurado. Verifique as variáveis de ambiente.');\n    }\n\n    const payload = {\n      version: this.whisperModel.split(':')[1], // Extrai o version ID\n      input: {\n        audio: audioUrl,\n        model: 'large-v3',\n        translate: options.translate || false,\n        language: options.language || null,\n        temperature: options.temperature || 0,\n        transcription: options.transcription || 'plain text',\n        suppress_tokens: options.suppress_tokens || '-1',\n        logprob_threshold: options.logprob_threshold || -1.0,\n        no_speech_threshold: options.no_speech_threshold || 0.6,\n        condition_on_previous_text: options.condition_on_previous_text !== false,\n        compression_ratio_threshold: options.compression_ratio_threshold || 2.4,\n        temperature_increment_on_fallback: options.temperature_increment_on_fallback || 0.2\n      },\n      webhook: this.webhookUrl,\n      webhook_events_filter: ['start', 'output', 'logs', 'completed']\n    };\n\n    try {\n      const response = await fetch(`${this.baseUrl}/predictions`, {\n        method: 'POST',\n        headers: {\n          'Authorization': `Bearer ${this.apiToken}`,\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify(payload)\n      });\n\n      if (!response.ok) {\n        const errorData = await response.json().catch(() => ({}));\n        throw new Error(`Erro na API Replicate: ${response.status} - ${errorData.detail || response.statusText}`);\n      }\n\n      const prediction = await response.json();\n      \n      // Salvar informações da predição no localStorage para acompanhamento\n      this.savePredictionInfo(prediction.id, {\n        id: prediction.id,\n        status: prediction.status,\n        audioUrl,\n        createdAt: new Date().toISOString(),\n        model: this.whisperModel,\n        options\n      });\n\n      return prediction;\n    } catch (error) {\n      console.error('Erro ao criar transcrição:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Consulta o status de uma predição\n   * @param {string} predictionId - ID da predição\n   * @returns {Promise<Object>} - Status atual da predição\n   */\n  async getPredictionStatus(predictionId) {\n    if (!this.isConfigured()) {\n      throw new Error('Replicate service não está configurado.');\n    }\n\n    try {\n      const response = await fetch(`${this.baseUrl}/predictions/${predictionId}`, {\n        headers: {\n          'Authorization': `Bearer ${this.apiToken}`,\n          'Content-Type': 'application/json',\n        }\n      });\n\n      if (!response.ok) {\n        const errorData = await response.json().catch(() => ({}));\n        throw new Error(`Erro ao consultar predição: ${response.status} - ${errorData.detail || response.statusText}`);\n      }\n\n      const prediction = await response.json();\n      \n      // Atualizar informações salvas\n      this.updatePredictionInfo(predictionId, {\n        status: prediction.status,\n        output: prediction.output,\n        error: prediction.error,\n        logs: prediction.logs,\n        updatedAt: new Date().toISOString()\n      });\n\n      return prediction;\n    } catch (error) {\n      console.error('Erro ao consultar status da predição:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Cancela uma predição em andamento\n   * @param {string} predictionId - ID da predição\n   * @returns {Promise<Object>} - Resultado do cancelamento\n   */\n  async cancelPrediction(predictionId) {\n    if (!this.isConfigured()) {\n      throw new Error('Replicate service não está configurado.');\n    }\n\n    try {\n      const response = await fetch(`${this.baseUrl}/predictions/${predictionId}/cancel`, {\n        method: 'POST',\n        headers: {\n          'Authorization': `Bearer ${this.apiToken}`,\n          'Content-Type': 'application/json',\n        }\n      });\n\n      if (!response.ok) {\n        const errorData = await response.json().catch(() => ({}));\n        throw new Error(`Erro ao cancelar predição: ${response.status} - ${errorData.detail || response.statusText}`);\n      }\n\n      const result = await response.json();\n      \n      // Atualizar status local\n      this.updatePredictionInfo(predictionId, {\n        status: 'canceled',\n        updatedAt: new Date().toISOString()\n      });\n\n      return result;\n    } catch (error) {\n      console.error('Erro ao cancelar predição:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Salva informações da predição no localStorage\n   * @param {string} predictionId - ID da predição\n   * @param {Object} info - Informações da predição\n   */\n  savePredictionInfo(predictionId, info) {\n    try {\n      const predictions = this.getAllPredictions();\n      predictions[predictionId] = info;\n      localStorage.setItem('replicate_predictions', JSON.stringify(predictions));\n    } catch (error) {\n      console.warn('Erro ao salvar informações da predição:', error);\n    }\n  }\n\n  /**\n   * Atualiza informações da predição no localStorage\n   * @param {string} predictionId - ID da predição\n   * @param {Object} updates - Atualizações\n   */\n  updatePredictionInfo(predictionId, updates) {\n    try {\n      const predictions = this.getAllPredictions();\n      if (predictions[predictionId]) {\n        predictions[predictionId] = { ...predictions[predictionId], ...updates };\n        localStorage.setItem('replicate_predictions', JSON.stringify(predictions));\n      }\n    } catch (error) {\n      console.warn('Erro ao atualizar informações da predição:', error);\n    }\n  }\n\n  /**\n   * Obtém informações de uma predição específica\n   * @param {string} predictionId - ID da predição\n   * @returns {Object|null} - Informações da predição\n   */\n  getPredictionInfo(predictionId) {\n    try {\n      const predictions = this.getAllPredictions();\n      return predictions[predictionId] || null;\n    } catch (error) {\n      console.warn('Erro ao obter informações da predição:', error);\n      return null;\n    }\n  }\n\n  /**\n   * Obtém todas as predições salvas\n   * @returns {Object} - Todas as predições\n   */\n  getAllPredictions() {\n    try {\n      const stored = localStorage.getItem('replicate_predictions');\n      return stored ? JSON.parse(stored) : {};\n    } catch (error) {\n      console.warn('Erro ao obter predições:', error);\n      return {};\n    }\n  }\n\n  /**\n   * Remove predições antigas (mais de 7 dias)\n   */\n  cleanupOldPredictions() {\n    try {\n      const predictions = this.getAllPredictions();\n      const sevenDaysAgo = new Date(Date.now() - 7 * 24 * 60 * 60 * 1000);\n      \n      Object.keys(predictions).forEach(id => {\n        const prediction = predictions[id];\n        const createdAt = new Date(prediction.createdAt);\n        \n        if (createdAt < sevenDaysAgo) {\n          delete predictions[id];\n        }\n      });\n      \n      localStorage.setItem('replicate_predictions', JSON.stringify(predictions));\n    } catch (error) {\n      console.warn('Erro ao limpar predições antigas:', error);\n    }\n  }\n\n  /**\n   * Obtém todas as predições do localStorage\n   * @returns {Object} - Objeto com todas as predições\n   */\n  getPredictions() {\n    try {\n      return this.getAllPredictions();\n    } catch (error) {\n      console.warn('Erro ao obter predições:', error);\n      return {};\n    }\n  }\n\n  /**\n   * Obtém predições ativas (em processamento)\n   * @returns {Array} - Lista de predições ativas\n   */\n  getActivePredictions() {\n    try {\n      const predictions = this.getAllPredictions();\n      return Object.values(predictions).filter(p => \n        ['starting', 'processing'].includes(p.status)\n      );\n    } catch (error) {\n      console.warn('Erro ao obter predições ativas:', error);\n      return [];\n    }\n  }\n}\n\n// Instância singleton\nconst replicateService = new ReplicateService();\n\n// Limpar predições antigas na inicialização\nreplicateService.cleanupOldPredictions();\n\nexport default replicateService;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}