{"ast":null,"code":"import config from'../config/env';/**\n * Serviço para verificação e processamento de webhooks do Replicate\n * Implementa verificação HMAC SHA-256 para autenticidade\n */class WebhookService{constructor(){this.webhookSecret=config.replicate.webhookSecret;}/**\n   * Verifica se o webhook está configurado\n   */isConfigured(){return!!this.webhookSecret;}/**\n   * Verifica a autenticidade de um webhook usando HMAC SHA-256\n   * @param {string} payload - Corpo da requisição (raw)\n   * @param {string} webhookId - ID do webhook (header webhook-id)\n   * @param {string} webhookTimestamp - Timestamp do webhook (header webhook-timestamp)\n   * @param {string} webhookSignature - Assinatura do webhook (header webhook-signature)\n   * @returns {boolean} - True se o webhook for válido\n   */async verifyWebhook(payload,webhookId,webhookTimestamp,webhookSignature){if(!this.isConfigured()){console.warn('Webhook secret não configurado');return false;}try{// Verificar timestamp para prevenir replay attacks (tolerância de 5 minutos)\nconst currentTime=Math.floor(Date.now()/1000);const webhookTime=parseInt(webhookTimestamp);const timeDiff=Math.abs(currentTime-webhookTime);if(timeDiff>300){// 5 minutos\nconsole.warn('Webhook timestamp muito antigo ou futuro:',timeDiff);return false;}// Construir o conteúdo assinado: id.timestamp.payload\nconst signedContent=`${webhookId}.${webhookTimestamp}.${payload}`;// Extrair a chave base64 (remover prefixo whsec_)\nconst secretKey=this.webhookSecret.startsWith('whsec_')?this.webhookSecret.substring(6):this.webhookSecret;// Calcular HMAC SHA-256\nconst expectedSignature=await this.calculateHMAC(signedContent,secretKey);// Extrair assinaturas do header (formato: \"v1,signature1 v1,signature2\")\nconst signatures=webhookSignature.split(' ').map(sig=>{const parts=sig.split(',');return parts.length===2?parts[1]:sig;});// Verificar se alguma assinatura coincide (comparação segura)\nreturn signatures.some(sig=>this.secureCompare(expectedSignature,sig));}catch(error){console.error('Erro ao verificar webhook:',error);return false;}}/**\n   * Calcula HMAC SHA-256\n   * @param {string} data - Dados para assinar\n   * @param {string} key - Chave secreta (base64)\n   * @returns {Promise<string>} - Assinatura HMAC em base64\n   */async calculateHMAC(data,key){// Converter chave base64 para ArrayBuffer\nconst keyBuffer=this.base64ToArrayBuffer(key);// Converter dados para ArrayBuffer\nconst dataBuffer=new TextEncoder().encode(data);// Importar chave para WebCrypto\nconst cryptoKey=await crypto.subtle.importKey('raw',keyBuffer,{name:'HMAC',hash:'SHA-256'},false,['sign']);// Calcular HMAC\nconst signature=await crypto.subtle.sign('HMAC',cryptoKey,dataBuffer);// Converter para base64\nreturn this.arrayBufferToBase64(signature);}/**\n   * Converte base64 para ArrayBuffer\n   * @param {string} base64 - String base64\n   * @returns {ArrayBuffer} - ArrayBuffer\n   */base64ToArrayBuffer(base64){const binaryString=atob(base64);const bytes=new Uint8Array(binaryString.length);for(let i=0;i<binaryString.length;i++){bytes[i]=binaryString.charCodeAt(i);}return bytes.buffer;}/**\n   * Converte ArrayBuffer para base64\n   * @param {ArrayBuffer} buffer - ArrayBuffer\n   * @returns {string} - String base64\n   */arrayBufferToBase64(buffer){const bytes=new Uint8Array(buffer);let binary='';for(let i=0;i<bytes.byteLength;i++){binary+=String.fromCharCode(bytes[i]);}return btoa(binary);}/**\n   * Comparação segura de strings para prevenir timing attacks\n   * @param {string} a - Primeira string\n   * @param {string} b - Segunda string\n   * @returns {boolean} - True se as strings forem iguais\n   */secureCompare(a,b){if(a.length!==b.length){return false;}let result=0;for(let i=0;i<a.length;i++){result|=a.charCodeAt(i)^b.charCodeAt(i);}return result===0;}/**\n   * Processa um webhook do Replicate\n   * @param {Object} webhookData - Dados do webhook\n   * @returns {Object} - Resultado do processamento\n   */processWebhook(webhookData){try{const{id,status,output,error,logs}=webhookData;// Atualizar informações da predição no localStorage\nif(typeof window!=='undefined'&&window.localStorage){const predictions=JSON.parse(localStorage.getItem('replicate_predictions')||'{}');if(predictions[id]){predictions[id]={...predictions[id],status,output,error,logs,updatedAt:new Date().toISOString(),webhookReceived:true};localStorage.setItem('replicate_predictions',JSON.stringify(predictions));// Disparar evento customizado para notificar componentes\nwindow.dispatchEvent(new CustomEvent('replicateWebhookReceived',{detail:{predictionId:id,status,output,error}}));}}return{success:true,predictionId:id,status,message:this.getStatusMessage(status)};}catch(error){console.error('Erro ao processar webhook:',error);return{success:false,error:error.message};}}/**\n   * Obtém mensagem amigável para o status\n   * @param {string} status - Status da predição\n   * @returns {string} - Mensagem amigável\n   */getStatusMessage(status){const messages={'starting':'Iniciando processamento...','processing':'Processando transcrição...','succeeded':'Transcrição concluída com sucesso!','failed':'Erro no processamento da transcrição','canceled':'Processamento cancelado'};return messages[status]||`Status: ${status}`;}/**\n   * Extrai texto da transcrição do output do Whisper\n   * @param {Object} output - Output da predição\n   * @returns {string} - Texto transcrito\n   */extractTranscriptionText(output){if(!output)return'';// O Whisper pode retornar diferentes formatos\nif(typeof output==='string'){return output;}if(output.text){return output.text;}if(output.transcription){return output.transcription;}if(output.segments&&Array.isArray(output.segments)){return output.segments.map(segment=>segment.text||'').join(' ');}return JSON.stringify(output);}/**\n   * Obtém informações detalhadas da transcrição\n   * @param {Object} output - Output da predição\n   * @returns {Object} - Informações detalhadas\n   */getTranscriptionDetails(output){if(!output)return null;return{text:this.extractTranscriptionText(output),segments:output.segments||[],language:output.language||'unknown',duration:output.duration||null,wordCount:this.extractTranscriptionText(output).split(/\\s+/).length};}}// Instância singleton\nconst webhookService=new WebhookService();export default webhookService;","map":{"version":3,"names":["config","WebhookService","constructor","webhookSecret","replicate","isConfigured","verifyWebhook","payload","webhookId","webhookTimestamp","webhookSignature","console","warn","currentTime","Math","floor","Date","now","webhookTime","parseInt","timeDiff","abs","signedContent","secretKey","startsWith","substring","expectedSignature","calculateHMAC","signatures","split","map","sig","parts","length","some","secureCompare","error","data","key","keyBuffer","base64ToArrayBuffer","dataBuffer","TextEncoder","encode","cryptoKey","crypto","subtle","importKey","name","hash","signature","sign","arrayBufferToBase64","base64","binaryString","atob","bytes","Uint8Array","i","charCodeAt","buffer","binary","byteLength","String","fromCharCode","btoa","a","b","result","processWebhook","webhookData","id","status","output","logs","window","localStorage","predictions","JSON","parse","getItem","updatedAt","toISOString","webhookReceived","setItem","stringify","dispatchEvent","CustomEvent","detail","predictionId","success","message","getStatusMessage","messages","extractTranscriptionText","text","transcription","segments","Array","isArray","segment","join","getTranscriptionDetails","language","duration","wordCount","webhookService"],"sources":["C:/Users/Afonso/Desktop/Transkipta/src/services/webhookService.js"],"sourcesContent":["import config from '../config/env';\n\n/**\n * Serviço para verificação e processamento de webhooks do Replicate\n * Implementa verificação HMAC SHA-256 para autenticidade\n */\nclass WebhookService {\n  constructor() {\n    this.webhookSecret = config.replicate.webhookSecret;\n  }\n\n  /**\n   * Verifica se o webhook está configurado\n   */\n  isConfigured() {\n    return !!this.webhookSecret;\n  }\n\n  /**\n   * Verifica a autenticidade de um webhook usando HMAC SHA-256\n   * @param {string} payload - Corpo da requisição (raw)\n   * @param {string} webhookId - ID do webhook (header webhook-id)\n   * @param {string} webhookTimestamp - Timestamp do webhook (header webhook-timestamp)\n   * @param {string} webhookSignature - Assinatura do webhook (header webhook-signature)\n   * @returns {boolean} - True se o webhook for válido\n   */\n  async verifyWebhook(payload, webhookId, webhookTimestamp, webhookSignature) {\n    if (!this.isConfigured()) {\n      console.warn('Webhook secret não configurado');\n      return false;\n    }\n\n    try {\n      // Verificar timestamp para prevenir replay attacks (tolerância de 5 minutos)\n      const currentTime = Math.floor(Date.now() / 1000);\n      const webhookTime = parseInt(webhookTimestamp);\n      const timeDiff = Math.abs(currentTime - webhookTime);\n      \n      if (timeDiff > 300) { // 5 minutos\n        console.warn('Webhook timestamp muito antigo ou futuro:', timeDiff);\n        return false;\n      }\n\n      // Construir o conteúdo assinado: id.timestamp.payload\n      const signedContent = `${webhookId}.${webhookTimestamp}.${payload}`;\n      \n      // Extrair a chave base64 (remover prefixo whsec_)\n      const secretKey = this.webhookSecret.startsWith('whsec_') \n        ? this.webhookSecret.substring(6) \n        : this.webhookSecret;\n      \n      // Calcular HMAC SHA-256\n      const expectedSignature = await this.calculateHMAC(signedContent, secretKey);\n      \n      // Extrair assinaturas do header (formato: \"v1,signature1 v1,signature2\")\n      const signatures = webhookSignature.split(' ').map(sig => {\n        const parts = sig.split(',');\n        return parts.length === 2 ? parts[1] : sig;\n      });\n      \n      // Verificar se alguma assinatura coincide (comparação segura)\n      return signatures.some(sig => this.secureCompare(expectedSignature, sig));\n      \n    } catch (error) {\n      console.error('Erro ao verificar webhook:', error);\n      return false;\n    }\n  }\n\n  /**\n   * Calcula HMAC SHA-256\n   * @param {string} data - Dados para assinar\n   * @param {string} key - Chave secreta (base64)\n   * @returns {Promise<string>} - Assinatura HMAC em base64\n   */\n  async calculateHMAC(data, key) {\n    // Converter chave base64 para ArrayBuffer\n    const keyBuffer = this.base64ToArrayBuffer(key);\n    \n    // Converter dados para ArrayBuffer\n    const dataBuffer = new TextEncoder().encode(data);\n    \n    // Importar chave para WebCrypto\n    const cryptoKey = await crypto.subtle.importKey(\n      'raw',\n      keyBuffer,\n      { name: 'HMAC', hash: 'SHA-256' },\n      false,\n      ['sign']\n    );\n    \n    // Calcular HMAC\n    const signature = await crypto.subtle.sign('HMAC', cryptoKey, dataBuffer);\n    \n    // Converter para base64\n    return this.arrayBufferToBase64(signature);\n  }\n\n  /**\n   * Converte base64 para ArrayBuffer\n   * @param {string} base64 - String base64\n   * @returns {ArrayBuffer} - ArrayBuffer\n   */\n  base64ToArrayBuffer(base64) {\n    const binaryString = atob(base64);\n    const bytes = new Uint8Array(binaryString.length);\n    for (let i = 0; i < binaryString.length; i++) {\n      bytes[i] = binaryString.charCodeAt(i);\n    }\n    return bytes.buffer;\n  }\n\n  /**\n   * Converte ArrayBuffer para base64\n   * @param {ArrayBuffer} buffer - ArrayBuffer\n   * @returns {string} - String base64\n   */\n  arrayBufferToBase64(buffer) {\n    const bytes = new Uint8Array(buffer);\n    let binary = '';\n    for (let i = 0; i < bytes.byteLength; i++) {\n      binary += String.fromCharCode(bytes[i]);\n    }\n    return btoa(binary);\n  }\n\n  /**\n   * Comparação segura de strings para prevenir timing attacks\n   * @param {string} a - Primeira string\n   * @param {string} b - Segunda string\n   * @returns {boolean} - True se as strings forem iguais\n   */\n  secureCompare(a, b) {\n    if (a.length !== b.length) {\n      return false;\n    }\n    \n    let result = 0;\n    for (let i = 0; i < a.length; i++) {\n      result |= a.charCodeAt(i) ^ b.charCodeAt(i);\n    }\n    \n    return result === 0;\n  }\n\n  /**\n   * Processa um webhook do Replicate\n   * @param {Object} webhookData - Dados do webhook\n   * @returns {Object} - Resultado do processamento\n   */\n  processWebhook(webhookData) {\n    try {\n      const { id, status, output, error, logs } = webhookData;\n      \n      // Atualizar informações da predição no localStorage\n      if (typeof window !== 'undefined' && window.localStorage) {\n        const predictions = JSON.parse(localStorage.getItem('replicate_predictions') || '{}');\n        \n        if (predictions[id]) {\n          predictions[id] = {\n            ...predictions[id],\n            status,\n            output,\n            error,\n            logs,\n            updatedAt: new Date().toISOString(),\n            webhookReceived: true\n          };\n          \n          localStorage.setItem('replicate_predictions', JSON.stringify(predictions));\n          \n          // Disparar evento customizado para notificar componentes\n          window.dispatchEvent(new CustomEvent('replicateWebhookReceived', {\n            detail: { predictionId: id, status, output, error }\n          }));\n        }\n      }\n      \n      return {\n        success: true,\n        predictionId: id,\n        status,\n        message: this.getStatusMessage(status)\n      };\n      \n    } catch (error) {\n      console.error('Erro ao processar webhook:', error);\n      return {\n        success: false,\n        error: error.message\n      };\n    }\n  }\n\n  /**\n   * Obtém mensagem amigável para o status\n   * @param {string} status - Status da predição\n   * @returns {string} - Mensagem amigável\n   */\n  getStatusMessage(status) {\n    const messages = {\n      'starting': 'Iniciando processamento...',\n      'processing': 'Processando transcrição...',\n      'succeeded': 'Transcrição concluída com sucesso!',\n      'failed': 'Erro no processamento da transcrição',\n      'canceled': 'Processamento cancelado'\n    };\n    \n    return messages[status] || `Status: ${status}`;\n  }\n\n  /**\n   * Extrai texto da transcrição do output do Whisper\n   * @param {Object} output - Output da predição\n   * @returns {string} - Texto transcrito\n   */\n  extractTranscriptionText(output) {\n    if (!output) return '';\n    \n    // O Whisper pode retornar diferentes formatos\n    if (typeof output === 'string') {\n      return output;\n    }\n    \n    if (output.text) {\n      return output.text;\n    }\n    \n    if (output.transcription) {\n      return output.transcription;\n    }\n    \n    if (output.segments && Array.isArray(output.segments)) {\n      return output.segments.map(segment => segment.text || '').join(' ');\n    }\n    \n    return JSON.stringify(output);\n  }\n\n  /**\n   * Obtém informações detalhadas da transcrição\n   * @param {Object} output - Output da predição\n   * @returns {Object} - Informações detalhadas\n   */\n  getTranscriptionDetails(output) {\n    if (!output) return null;\n    \n    return {\n      text: this.extractTranscriptionText(output),\n      segments: output.segments || [],\n      language: output.language || 'unknown',\n      duration: output.duration || null,\n      wordCount: this.extractTranscriptionText(output).split(/\\s+/).length\n    };\n  }\n}\n\n// Instância singleton\nconst webhookService = new WebhookService();\n\nexport default webhookService;"],"mappings":"AAAA,MAAO,CAAAA,MAAM,KAAM,eAAe,CAElC;AACA;AACA;AACA,GACA,KAAM,CAAAC,cAAe,CACnBC,WAAWA,CAAA,CAAG,CACZ,IAAI,CAACC,aAAa,CAAGH,MAAM,CAACI,SAAS,CAACD,aAAa,CACrD,CAEA;AACF;AACA,KACEE,YAAYA,CAAA,CAAG,CACb,MAAO,CAAC,CAAC,IAAI,CAACF,aAAa,CAC7B,CAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA,KACE,KAAM,CAAAG,aAAaA,CAACC,OAAO,CAAEC,SAAS,CAAEC,gBAAgB,CAAEC,gBAAgB,CAAE,CAC1E,GAAI,CAAC,IAAI,CAACL,YAAY,CAAC,CAAC,CAAE,CACxBM,OAAO,CAACC,IAAI,CAAC,gCAAgC,CAAC,CAC9C,MAAO,MAAK,CACd,CAEA,GAAI,CACF;AACA,KAAM,CAAAC,WAAW,CAAGC,IAAI,CAACC,KAAK,CAACC,IAAI,CAACC,GAAG,CAAC,CAAC,CAAG,IAAI,CAAC,CACjD,KAAM,CAAAC,WAAW,CAAGC,QAAQ,CAACV,gBAAgB,CAAC,CAC9C,KAAM,CAAAW,QAAQ,CAAGN,IAAI,CAACO,GAAG,CAACR,WAAW,CAAGK,WAAW,CAAC,CAEpD,GAAIE,QAAQ,CAAG,GAAG,CAAE,CAAE;AACpBT,OAAO,CAACC,IAAI,CAAC,2CAA2C,CAAEQ,QAAQ,CAAC,CACnE,MAAO,MAAK,CACd,CAEA;AACA,KAAM,CAAAE,aAAa,CAAG,GAAGd,SAAS,IAAIC,gBAAgB,IAAIF,OAAO,EAAE,CAEnE;AACA,KAAM,CAAAgB,SAAS,CAAG,IAAI,CAACpB,aAAa,CAACqB,UAAU,CAAC,QAAQ,CAAC,CACrD,IAAI,CAACrB,aAAa,CAACsB,SAAS,CAAC,CAAC,CAAC,CAC/B,IAAI,CAACtB,aAAa,CAEtB;AACA,KAAM,CAAAuB,iBAAiB,CAAG,KAAM,KAAI,CAACC,aAAa,CAACL,aAAa,CAAEC,SAAS,CAAC,CAE5E;AACA,KAAM,CAAAK,UAAU,CAAGlB,gBAAgB,CAACmB,KAAK,CAAC,GAAG,CAAC,CAACC,GAAG,CAACC,GAAG,EAAI,CACxD,KAAM,CAAAC,KAAK,CAAGD,GAAG,CAACF,KAAK,CAAC,GAAG,CAAC,CAC5B,MAAO,CAAAG,KAAK,CAACC,MAAM,GAAK,CAAC,CAAGD,KAAK,CAAC,CAAC,CAAC,CAAGD,GAAG,CAC5C,CAAC,CAAC,CAEF;AACA,MAAO,CAAAH,UAAU,CAACM,IAAI,CAACH,GAAG,EAAI,IAAI,CAACI,aAAa,CAACT,iBAAiB,CAAEK,GAAG,CAAC,CAAC,CAE3E,CAAE,MAAOK,KAAK,CAAE,CACdzB,OAAO,CAACyB,KAAK,CAAC,4BAA4B,CAAEA,KAAK,CAAC,CAClD,MAAO,MAAK,CACd,CACF,CAEA;AACF;AACA;AACA;AACA;AACA,KACE,KAAM,CAAAT,aAAaA,CAACU,IAAI,CAAEC,GAAG,CAAE,CAC7B;AACA,KAAM,CAAAC,SAAS,CAAG,IAAI,CAACC,mBAAmB,CAACF,GAAG,CAAC,CAE/C;AACA,KAAM,CAAAG,UAAU,CAAG,GAAI,CAAAC,WAAW,CAAC,CAAC,CAACC,MAAM,CAACN,IAAI,CAAC,CAEjD;AACA,KAAM,CAAAO,SAAS,CAAG,KAAM,CAAAC,MAAM,CAACC,MAAM,CAACC,SAAS,CAC7C,KAAK,CACLR,SAAS,CACT,CAAES,IAAI,CAAE,MAAM,CAAEC,IAAI,CAAE,SAAU,CAAC,CACjC,KAAK,CACL,CAAC,MAAM,CACT,CAAC,CAED;AACA,KAAM,CAAAC,SAAS,CAAG,KAAM,CAAAL,MAAM,CAACC,MAAM,CAACK,IAAI,CAAC,MAAM,CAAEP,SAAS,CAAEH,UAAU,CAAC,CAEzE;AACA,MAAO,KAAI,CAACW,mBAAmB,CAACF,SAAS,CAAC,CAC5C,CAEA;AACF;AACA;AACA;AACA,KACEV,mBAAmBA,CAACa,MAAM,CAAE,CAC1B,KAAM,CAAAC,YAAY,CAAGC,IAAI,CAACF,MAAM,CAAC,CACjC,KAAM,CAAAG,KAAK,CAAG,GAAI,CAAAC,UAAU,CAACH,YAAY,CAACrB,MAAM,CAAC,CACjD,IAAK,GAAI,CAAAyB,CAAC,CAAG,CAAC,CAAEA,CAAC,CAAGJ,YAAY,CAACrB,MAAM,CAAEyB,CAAC,EAAE,CAAE,CAC5CF,KAAK,CAACE,CAAC,CAAC,CAAGJ,YAAY,CAACK,UAAU,CAACD,CAAC,CAAC,CACvC,CACA,MAAO,CAAAF,KAAK,CAACI,MAAM,CACrB,CAEA;AACF;AACA;AACA;AACA,KACER,mBAAmBA,CAACQ,MAAM,CAAE,CAC1B,KAAM,CAAAJ,KAAK,CAAG,GAAI,CAAAC,UAAU,CAACG,MAAM,CAAC,CACpC,GAAI,CAAAC,MAAM,CAAG,EAAE,CACf,IAAK,GAAI,CAAAH,CAAC,CAAG,CAAC,CAAEA,CAAC,CAAGF,KAAK,CAACM,UAAU,CAAEJ,CAAC,EAAE,CAAE,CACzCG,MAAM,EAAIE,MAAM,CAACC,YAAY,CAACR,KAAK,CAACE,CAAC,CAAC,CAAC,CACzC,CACA,MAAO,CAAAO,IAAI,CAACJ,MAAM,CAAC,CACrB,CAEA;AACF;AACA;AACA;AACA;AACA,KACE1B,aAAaA,CAAC+B,CAAC,CAAEC,CAAC,CAAE,CAClB,GAAID,CAAC,CAACjC,MAAM,GAAKkC,CAAC,CAAClC,MAAM,CAAE,CACzB,MAAO,MAAK,CACd,CAEA,GAAI,CAAAmC,MAAM,CAAG,CAAC,CACd,IAAK,GAAI,CAAAV,CAAC,CAAG,CAAC,CAAEA,CAAC,CAAGQ,CAAC,CAACjC,MAAM,CAAEyB,CAAC,EAAE,CAAE,CACjCU,MAAM,EAAIF,CAAC,CAACP,UAAU,CAACD,CAAC,CAAC,CAAGS,CAAC,CAACR,UAAU,CAACD,CAAC,CAAC,CAC7C,CAEA,MAAO,CAAAU,MAAM,GAAK,CAAC,CACrB,CAEA;AACF;AACA;AACA;AACA,KACEC,cAAcA,CAACC,WAAW,CAAE,CAC1B,GAAI,CACF,KAAM,CAAEC,EAAE,CAAEC,MAAM,CAAEC,MAAM,CAAErC,KAAK,CAAEsC,IAAK,CAAC,CAAGJ,WAAW,CAEvD;AACA,GAAI,MAAO,CAAAK,MAAM,GAAK,WAAW,EAAIA,MAAM,CAACC,YAAY,CAAE,CACxD,KAAM,CAAAC,WAAW,CAAGC,IAAI,CAACC,KAAK,CAACH,YAAY,CAACI,OAAO,CAAC,uBAAuB,CAAC,EAAI,IAAI,CAAC,CAErF,GAAIH,WAAW,CAACN,EAAE,CAAC,CAAE,CACnBM,WAAW,CAACN,EAAE,CAAC,CAAG,CAChB,GAAGM,WAAW,CAACN,EAAE,CAAC,CAClBC,MAAM,CACNC,MAAM,CACNrC,KAAK,CACLsC,IAAI,CACJO,SAAS,CAAE,GAAI,CAAAjE,IAAI,CAAC,CAAC,CAACkE,WAAW,CAAC,CAAC,CACnCC,eAAe,CAAE,IACnB,CAAC,CAEDP,YAAY,CAACQ,OAAO,CAAC,uBAAuB,CAAEN,IAAI,CAACO,SAAS,CAACR,WAAW,CAAC,CAAC,CAE1E;AACAF,MAAM,CAACW,aAAa,CAAC,GAAI,CAAAC,WAAW,CAAC,0BAA0B,CAAE,CAC/DC,MAAM,CAAE,CAAEC,YAAY,CAAElB,EAAE,CAAEC,MAAM,CAAEC,MAAM,CAAErC,KAAM,CACpD,CAAC,CAAC,CAAC,CACL,CACF,CAEA,MAAO,CACLsD,OAAO,CAAE,IAAI,CACbD,YAAY,CAAElB,EAAE,CAChBC,MAAM,CACNmB,OAAO,CAAE,IAAI,CAACC,gBAAgB,CAACpB,MAAM,CACvC,CAAC,CAEH,CAAE,MAAOpC,KAAK,CAAE,CACdzB,OAAO,CAACyB,KAAK,CAAC,4BAA4B,CAAEA,KAAK,CAAC,CAClD,MAAO,CACLsD,OAAO,CAAE,KAAK,CACdtD,KAAK,CAAEA,KAAK,CAACuD,OACf,CAAC,CACH,CACF,CAEA;AACF;AACA;AACA;AACA,KACEC,gBAAgBA,CAACpB,MAAM,CAAE,CACvB,KAAM,CAAAqB,QAAQ,CAAG,CACf,UAAU,CAAE,4BAA4B,CACxC,YAAY,CAAE,4BAA4B,CAC1C,WAAW,CAAE,oCAAoC,CACjD,QAAQ,CAAE,sCAAsC,CAChD,UAAU,CAAE,yBACd,CAAC,CAED,MAAO,CAAAA,QAAQ,CAACrB,MAAM,CAAC,EAAI,WAAWA,MAAM,EAAE,CAChD,CAEA;AACF;AACA;AACA;AACA,KACEsB,wBAAwBA,CAACrB,MAAM,CAAE,CAC/B,GAAI,CAACA,MAAM,CAAE,MAAO,EAAE,CAEtB;AACA,GAAI,MAAO,CAAAA,MAAM,GAAK,QAAQ,CAAE,CAC9B,MAAO,CAAAA,MAAM,CACf,CAEA,GAAIA,MAAM,CAACsB,IAAI,CAAE,CACf,MAAO,CAAAtB,MAAM,CAACsB,IAAI,CACpB,CAEA,GAAItB,MAAM,CAACuB,aAAa,CAAE,CACxB,MAAO,CAAAvB,MAAM,CAACuB,aAAa,CAC7B,CAEA,GAAIvB,MAAM,CAACwB,QAAQ,EAAIC,KAAK,CAACC,OAAO,CAAC1B,MAAM,CAACwB,QAAQ,CAAC,CAAE,CACrD,MAAO,CAAAxB,MAAM,CAACwB,QAAQ,CAACnE,GAAG,CAACsE,OAAO,EAAIA,OAAO,CAACL,IAAI,EAAI,EAAE,CAAC,CAACM,IAAI,CAAC,GAAG,CAAC,CACrE,CAEA,MAAO,CAAAvB,IAAI,CAACO,SAAS,CAACZ,MAAM,CAAC,CAC/B,CAEA;AACF;AACA;AACA;AACA,KACE6B,uBAAuBA,CAAC7B,MAAM,CAAE,CAC9B,GAAI,CAACA,MAAM,CAAE,MAAO,KAAI,CAExB,MAAO,CACLsB,IAAI,CAAE,IAAI,CAACD,wBAAwB,CAACrB,MAAM,CAAC,CAC3CwB,QAAQ,CAAExB,MAAM,CAACwB,QAAQ,EAAI,EAAE,CAC/BM,QAAQ,CAAE9B,MAAM,CAAC8B,QAAQ,EAAI,SAAS,CACtCC,QAAQ,CAAE/B,MAAM,CAAC+B,QAAQ,EAAI,IAAI,CACjCC,SAAS,CAAE,IAAI,CAACX,wBAAwB,CAACrB,MAAM,CAAC,CAAC5C,KAAK,CAAC,KAAK,CAAC,CAACI,MAChE,CAAC,CACH,CACF,CAEA;AACA,KAAM,CAAAyE,cAAc,CAAG,GAAI,CAAAzG,cAAc,CAAC,CAAC,CAE3C,cAAe,CAAAyG,cAAc","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}