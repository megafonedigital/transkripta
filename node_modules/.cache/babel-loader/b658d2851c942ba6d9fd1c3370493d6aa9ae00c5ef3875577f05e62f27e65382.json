{"ast":null,"code":"import axios from 'axios';\nimport config from '../config/env';\n\n// Configurações das APIs\nconst OPENAI_API_KEY = config.openai.apiKey;\nconst OPENAI_API_URL = config.openai.baseUrl;\nconst RAPIDAPI_KEY = config.rapidapi.key;\nconst RAPIDAPI_HOST = config.rapidapi.host;\nconst COBALT_API_URL = config.cobalt.apiUrl;\nconst API_TIMEOUT = config.api.timeout;\n\n// Create axios instances\nconst openaiApi = axios.create({\n  baseURL: OPENAI_API_URL,\n  timeout: API_TIMEOUT,\n  headers: {\n    'Authorization': `Bearer ${OPENAI_API_KEY}`,\n    'Content-Type': 'application/json'\n  }\n});\nconst rapidApi = axios.create({\n  timeout: API_TIMEOUT,\n  headers: {\n    'X-RapidAPI-Key': RAPIDAPI_KEY,\n    'X-RapidAPI-Host': RAPIDAPI_HOST\n  }\n});\nconst cobaltApi = axios.create({\n  baseURL: COBALT_API_URL,\n  timeout: API_TIMEOUT,\n  headers: {\n    'Content-Type': 'application/json',\n    'Accept': 'application/json'\n  }\n});\n\n// Video Download Functions\nexport const downloadVideo = async (url, platform) => {\n  try {\n    let downloadUrl;\n\n    // Priorizar Cobalt como serviço principal\n    try {\n      console.log('Tentando download via Cobalt...');\n      downloadUrl = await downloadFromCobalt(url);\n    } catch (cobaltError) {\n      console.warn('Falha no Cobalt, tentando alternativas:', cobaltError.message);\n\n      // Fallback para RapidAPI apenas para YouTube\n      if (platform === 'youtube') {\n        try {\n          console.log('Tentando download via RapidAPI...');\n          downloadUrl = await downloadFromYoutube(url);\n        } catch (rapidError) {\n          console.error('Falha no RapidAPI:', rapidError.message);\n          throw new Error('Todos os serviços de download falharam');\n        }\n      } else {\n        throw cobaltError;\n      }\n    }\n    if (!downloadUrl) {\n      throw new Error('Não foi possível obter URL de download');\n    }\n    console.log('URL de download obtida:', downloadUrl);\n\n    // Download the actual file\n    const response = await axios.get(downloadUrl, {\n      responseType: 'blob',\n      timeout: API_TIMEOUT * 2,\n      // Mais tempo para download de arquivos grandes\n      onDownloadProgress: progressEvent => {\n        if (progressEvent.total) {\n          const progress = Math.round(progressEvent.loaded * 100 / progressEvent.total);\n          console.log(`Download progress: ${progress}%`);\n        }\n      }\n    });\n    return response.data;\n  } catch (error) {\n    console.error('Erro no download do vídeo:', error);\n    throw handleApiError(error);\n  }\n};\nconst downloadFromYoutube = async url => {\n  try {\n    const response = await rapidApi.get('/dl', {\n      params: {\n        id: extractVideoId(url)\n      }\n    });\n    if (response.data && response.data.link) {\n      return response.data.link;\n    }\n    throw new Error('URL de download não encontrada');\n  } catch (error) {\n    throw new Error(`Erro no download do YouTube: ${error.message}`);\n  }\n};\nconst downloadFromCobalt = async url => {\n  try {\n    console.log('Iniciando download via Cobalt para URL:', url);\n    const requestData = {\n      url: url,\n      vCodec: 'h264',\n      vQuality: '720',\n      aFormat: 'mp3',\n      isAudioOnly: false,\n      isAudioMuted: false,\n      dubLang: false,\n      filenamePattern: 'classic'\n    };\n    console.log('Dados da requisição Cobalt:', requestData);\n    const response = await cobaltApi.post('/api/json', requestData);\n    console.log('Resposta do Cobalt:', response.data);\n    if (response.data) {\n      // Cobalt pode retornar diferentes formatos de resposta\n      if (response.data.url) {\n        return response.data.url;\n      } else if (response.data.picker && response.data.picker.length > 0) {\n        // Se houver múltiplas opções, pegar a primeira\n        return response.data.picker[0].url;\n      } else if (response.data.audio) {\n        // Se for apenas áudio\n        return response.data.audio;\n      }\n    }\n    throw new Error('URL de download não encontrada na resposta do Cobalt');\n  } catch (error) {\n    var _error$response, _error$response2, _error$response3, _error$response4;\n    console.error('Erro detalhado no Cobalt:', ((_error$response = error.response) === null || _error$response === void 0 ? void 0 : _error$response.data) || error.message);\n    if (((_error$response2 = error.response) === null || _error$response2 === void 0 ? void 0 : _error$response2.status) === 400) {\n      throw new Error('URL inválida ou não suportada pelo Cobalt');\n    } else if (((_error$response3 = error.response) === null || _error$response3 === void 0 ? void 0 : _error$response3.status) === 429) {\n      throw new Error('Limite de requisições excedido no Cobalt');\n    } else if (((_error$response4 = error.response) === null || _error$response4 === void 0 ? void 0 : _error$response4.status) >= 500) {\n      throw new Error('Erro interno do servidor Cobalt');\n    }\n    throw new Error(`Erro no download via Cobalt: ${error.message}`);\n  }\n};\n\n// Transcription Functions\nexport const transcribeAudio = async (audioFile, options = {}) => {\n  try {\n    const formData = new FormData();\n    formData.append('file', audioFile);\n    formData.append('model', options.model || 'whisper-1');\n    if (options.language) {\n      formData.append('language', options.language);\n    }\n    if (options.prompt) {\n      formData.append('prompt', options.prompt);\n    }\n    const response = await openaiApi.post('/audio/transcriptions', formData, {\n      headers: {\n        'Content-Type': 'multipart/form-data'\n      }\n    });\n    return {\n      text: response.data.text,\n      language: response.data.language || options.language,\n      duration: response.data.duration\n    };\n  } catch (error) {\n    console.error('Erro na transcrição:', error);\n    throw new Error(`Falha na transcrição: ${error.message}`);\n  }\n};\n\n// Utility Functions\nconst extractVideoId = url => {\n  const regex = /(?:youtube\\.com\\/(?:[^\\/]+\\/.+\\/|(?:v|e(?:mbed)?)\\/|.*[?&]v=)|youtu\\.be\\/)([^\"&?\\/\\s]{11})/;\n  const match = url.match(regex);\n  return match ? match[1] : null;\n};\nexport const validateVideoUrl = url => {\n  const patterns = {\n    youtube: /(?:youtube\\.com\\/(?:[^\\/]+\\/.+\\/|(?:v|e(?:mbed)?)\\/|.*[?&]v=)|youtu\\.be\\/)/,\n    instagram: /(?:instagram\\.com\\/(?:p|reel|tv)\\/)/,\n    tiktok: /(?:tiktok\\.com\\/@[^\\/]+\\/video\\/|vm\\.tiktok\\.com\\/)/\n  };\n  for (const [platform, pattern] of Object.entries(patterns)) {\n    if (pattern.test(url)) {\n      return platform;\n    }\n  }\n  return null;\n};\n\n// File Processing\nexport const convertToAudio = async videoBlob => {\n  return new Promise((resolve, reject) => {\n    const audio = document.createElement('audio');\n    const url = URL.createObjectURL(videoBlob);\n    audio.src = url;\n    audio.addEventListener('loadedmetadata', () => {\n      // For now, we'll return the original blob\n      // In a real implementation, you might want to use FFmpeg.js\n      resolve(videoBlob);\n      URL.revokeObjectURL(url);\n    });\n    audio.addEventListener('error', () => {\n      reject(new Error('Erro ao processar o arquivo de áudio'));\n      URL.revokeObjectURL(url);\n    });\n  });\n};\n\n// Error Handling\nexport const handleApiError = error => {\n  if (error.response) {\n    var _error$response$data;\n    // Server responded with error status\n    const status = error.response.status;\n    const message = ((_error$response$data = error.response.data) === null || _error$response$data === void 0 ? void 0 : _error$response$data.message) || error.message;\n    switch (status) {\n      case 401:\n        return 'Chave de API inválida ou expirada';\n      case 403:\n        return 'Acesso negado. Verifique suas permissões';\n      case 429:\n        return 'Limite de requisições excedido. Tente novamente mais tarde';\n      case 500:\n        return 'Erro interno do servidor';\n      default:\n        return `Erro ${status}: ${message}`;\n    }\n  } else if (error.request) {\n    // Network error\n    return 'Erro de conexão. Verifique sua internet';\n  } else {\n    // Other error\n    return error.message || 'Erro desconhecido';\n  }\n};","map":{"version":3,"names":["axios","config","OPENAI_API_KEY","openai","apiKey","OPENAI_API_URL","baseUrl","RAPIDAPI_KEY","rapidapi","key","RAPIDAPI_HOST","host","COBALT_API_URL","cobalt","apiUrl","API_TIMEOUT","api","timeout","openaiApi","create","baseURL","headers","rapidApi","cobaltApi","downloadVideo","url","platform","downloadUrl","console","log","downloadFromCobalt","cobaltError","warn","message","downloadFromYoutube","rapidError","error","Error","response","get","responseType","onDownloadProgress","progressEvent","total","progress","Math","round","loaded","data","handleApiError","params","id","extractVideoId","link","requestData","vCodec","vQuality","aFormat","isAudioOnly","isAudioMuted","dubLang","filenamePattern","post","picker","length","audio","_error$response","_error$response2","_error$response3","_error$response4","status","transcribeAudio","audioFile","options","formData","FormData","append","model","language","prompt","text","duration","regex","match","validateVideoUrl","patterns","youtube","instagram","tiktok","pattern","Object","entries","test","convertToAudio","videoBlob","Promise","resolve","reject","document","createElement","URL","createObjectURL","src","addEventListener","revokeObjectURL","_error$response$data","request"],"sources":["C:/Users/Afonso/Desktop/Transkipta/src/services/apiService.js"],"sourcesContent":["import axios from 'axios';\nimport config from '../config/env';\n\n// Configurações das APIs\nconst OPENAI_API_KEY = config.openai.apiKey;\nconst OPENAI_API_URL = config.openai.baseUrl;\nconst RAPIDAPI_KEY = config.rapidapi.key;\nconst RAPIDAPI_HOST = config.rapidapi.host;\nconst COBALT_API_URL = config.cobalt.apiUrl;\nconst API_TIMEOUT = config.api.timeout;\n\n// Create axios instances\nconst openaiApi = axios.create({\n  baseURL: OPENAI_API_URL,\n  timeout: API_TIMEOUT,\n  headers: {\n    'Authorization': `Bearer ${OPENAI_API_KEY}`,\n    'Content-Type': 'application/json'\n  }\n});\n\nconst rapidApi = axios.create({\n  timeout: API_TIMEOUT,\n  headers: {\n    'X-RapidAPI-Key': RAPIDAPI_KEY,\n    'X-RapidAPI-Host': RAPIDAPI_HOST\n  }\n});\n\nconst cobaltApi = axios.create({\n  baseURL: COBALT_API_URL,\n  timeout: API_TIMEOUT,\n  headers: {\n    'Content-Type': 'application/json',\n    'Accept': 'application/json'\n  }\n});\n\n// Video Download Functions\nexport const downloadVideo = async (url, platform) => {\n  try {\n    let downloadUrl;\n    \n    // Priorizar Cobalt como serviço principal\n    try {\n      console.log('Tentando download via Cobalt...');\n      downloadUrl = await downloadFromCobalt(url);\n    } catch (cobaltError) {\n      console.warn('Falha no Cobalt, tentando alternativas:', cobaltError.message);\n      \n      // Fallback para RapidAPI apenas para YouTube\n      if (platform === 'youtube') {\n        try {\n          console.log('Tentando download via RapidAPI...');\n          downloadUrl = await downloadFromYoutube(url);\n        } catch (rapidError) {\n          console.error('Falha no RapidAPI:', rapidError.message);\n          throw new Error('Todos os serviços de download falharam');\n        }\n      } else {\n        throw cobaltError;\n      }\n    }\n    \n    if (!downloadUrl) {\n      throw new Error('Não foi possível obter URL de download');\n    }\n    \n    console.log('URL de download obtida:', downloadUrl);\n    \n    // Download the actual file\n    const response = await axios.get(downloadUrl, {\n      responseType: 'blob',\n      timeout: API_TIMEOUT * 2, // Mais tempo para download de arquivos grandes\n      onDownloadProgress: (progressEvent) => {\n        if (progressEvent.total) {\n          const progress = Math.round((progressEvent.loaded * 100) / progressEvent.total);\n          console.log(`Download progress: ${progress}%`);\n        }\n      }\n    });\n    \n    return response.data;\n  } catch (error) {\n    console.error('Erro no download do vídeo:', error);\n    throw handleApiError(error);\n  }\n};\n\nconst downloadFromYoutube = async (url) => {\n  try {\n    const response = await rapidApi.get('/dl', {\n      params: {\n        id: extractVideoId(url)\n      }\n    });\n    \n    if (response.data && response.data.link) {\n      return response.data.link;\n    }\n    throw new Error('URL de download não encontrada');\n  } catch (error) {\n    throw new Error(`Erro no download do YouTube: ${error.message}`);\n  }\n};\n\nconst downloadFromCobalt = async (url) => {\n  try {\n    console.log('Iniciando download via Cobalt para URL:', url);\n    \n    const requestData = {\n      url: url,\n      vCodec: 'h264',\n      vQuality: '720',\n      aFormat: 'mp3',\n      isAudioOnly: false,\n      isAudioMuted: false,\n      dubLang: false,\n      filenamePattern: 'classic'\n    };\n    \n    console.log('Dados da requisição Cobalt:', requestData);\n    \n    const response = await cobaltApi.post('/api/json', requestData);\n    \n    console.log('Resposta do Cobalt:', response.data);\n    \n    if (response.data) {\n      // Cobalt pode retornar diferentes formatos de resposta\n      if (response.data.url) {\n        return response.data.url;\n      } else if (response.data.picker && response.data.picker.length > 0) {\n        // Se houver múltiplas opções, pegar a primeira\n        return response.data.picker[0].url;\n      } else if (response.data.audio) {\n        // Se for apenas áudio\n        return response.data.audio;\n      }\n    }\n    \n    throw new Error('URL de download não encontrada na resposta do Cobalt');\n  } catch (error) {\n    console.error('Erro detalhado no Cobalt:', error.response?.data || error.message);\n    \n    if (error.response?.status === 400) {\n      throw new Error('URL inválida ou não suportada pelo Cobalt');\n    } else if (error.response?.status === 429) {\n      throw new Error('Limite de requisições excedido no Cobalt');\n    } else if (error.response?.status >= 500) {\n      throw new Error('Erro interno do servidor Cobalt');\n    }\n    \n    throw new Error(`Erro no download via Cobalt: ${error.message}`);\n   }\n };\n\n// Transcription Functions\nexport const transcribeAudio = async (audioFile, options = {}) => {\n  try {\n    const formData = new FormData();\n    formData.append('file', audioFile);\n    formData.append('model', options.model || 'whisper-1');\n    \n    if (options.language) {\n      formData.append('language', options.language);\n    }\n    \n    if (options.prompt) {\n      formData.append('prompt', options.prompt);\n    }\n    \n    const response = await openaiApi.post('/audio/transcriptions', formData, {\n      headers: {\n        'Content-Type': 'multipart/form-data'\n      }\n    });\n    \n    return {\n      text: response.data.text,\n      language: response.data.language || options.language,\n      duration: response.data.duration\n    };\n  } catch (error) {\n    console.error('Erro na transcrição:', error);\n    throw new Error(`Falha na transcrição: ${error.message}`);\n  }\n};\n\n// Utility Functions\nconst extractVideoId = (url) => {\n  const regex = /(?:youtube\\.com\\/(?:[^\\/]+\\/.+\\/|(?:v|e(?:mbed)?)\\/|.*[?&]v=)|youtu\\.be\\/)([^\"&?\\/\\s]{11})/;\n  const match = url.match(regex);\n  return match ? match[1] : null;\n};\n\nexport const validateVideoUrl = (url) => {\n  const patterns = {\n    youtube: /(?:youtube\\.com\\/(?:[^\\/]+\\/.+\\/|(?:v|e(?:mbed)?)\\/|.*[?&]v=)|youtu\\.be\\/)/,\n    instagram: /(?:instagram\\.com\\/(?:p|reel|tv)\\/)/,\n    tiktok: /(?:tiktok\\.com\\/@[^\\/]+\\/video\\/|vm\\.tiktok\\.com\\/)/\n  };\n  \n  for (const [platform, pattern] of Object.entries(patterns)) {\n    if (pattern.test(url)) {\n      return platform;\n    }\n  }\n  \n  return null;\n};\n\n// File Processing\nexport const convertToAudio = async (videoBlob) => {\n  return new Promise((resolve, reject) => {\n    const audio = document.createElement('audio');\n    const url = URL.createObjectURL(videoBlob);\n    \n    audio.src = url;\n    audio.addEventListener('loadedmetadata', () => {\n      // For now, we'll return the original blob\n      // In a real implementation, you might want to use FFmpeg.js\n      resolve(videoBlob);\n      URL.revokeObjectURL(url);\n    });\n    \n    audio.addEventListener('error', () => {\n      reject(new Error('Erro ao processar o arquivo de áudio'));\n      URL.revokeObjectURL(url);\n    });\n  });\n};\n\n// Error Handling\nexport const handleApiError = (error) => {\n  if (error.response) {\n    // Server responded with error status\n    const status = error.response.status;\n    const message = error.response.data?.message || error.message;\n    \n    switch (status) {\n      case 401:\n        return 'Chave de API inválida ou expirada';\n      case 403:\n        return 'Acesso negado. Verifique suas permissões';\n      case 429:\n        return 'Limite de requisições excedido. Tente novamente mais tarde';\n      case 500:\n        return 'Erro interno do servidor';\n      default:\n        return `Erro ${status}: ${message}`;\n    }\n  } else if (error.request) {\n    // Network error\n    return 'Erro de conexão. Verifique sua internet';\n  } else {\n    // Other error\n    return error.message || 'Erro desconhecido';\n  }\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}