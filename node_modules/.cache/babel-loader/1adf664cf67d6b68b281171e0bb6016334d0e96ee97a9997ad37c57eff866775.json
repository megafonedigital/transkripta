{"ast":null,"code":"import config from '../config/env';\n\n// Local Authentication Service\nconst JWT_SECRET = config.auth.jwtSecret;\nconst SESSION_TIMEOUT = config.auth.sessionTimeout;\n\n// Simple JWT-like token generation (for demo purposes)\nconst generateToken = userData => {\n  const payload = {\n    ...userData,\n    exp: Date.now() + SESSION_TIMEOUT,\n    iat: Date.now()\n  };\n\n  // In a real app, you'd use a proper JWT library\n  return btoa(JSON.stringify(payload));\n};\nconst decodeToken = token => {\n  try {\n    return JSON.parse(atob(token));\n  } catch (error) {\n    return null;\n  }\n};\n\n// Default users (in a real app, this would be handled by a proper auth service)\nconst getDefaultUsers = () => {\n  // Verificar se as credenciais estão definidas nas variáveis de ambiente\n  const adminUsername = config.auth.adminUsername;\n  const adminEmail = config.auth.adminEmail;\n  const adminPassword = config.auth.adminPassword;\n  const userUsername = config.auth.userUsername;\n  const userEmail = config.auth.userEmail;\n  const userPassword = config.auth.userPassword;\n  if (!adminUsername || !adminEmail || !adminPassword || !userUsername || !userEmail || !userPassword) {\n    throw new Error('Credenciais de usuário não configuradas nas variáveis de ambiente');\n  }\n  return [{\n    id: 1,\n    username: adminUsername,\n    email: adminEmail,\n    password: adminPassword,\n    // In production, this would be hashed\n    role: 'admin'\n  }, {\n    id: 2,\n    username: userUsername,\n    email: userEmail,\n    password: userPassword,\n    role: 'user'\n  }];\n};\n\n// Storage keys\nconst STORAGE_KEYS = {\n  TOKEN: 'transkipta_token',\n  USER: 'transkipta_user',\n  USERS: 'transkipta_users'\n};\n\n// Initialize default users if not exists\nconst initializeUsers = () => {\n  const existingUsers = localStorage.getItem(STORAGE_KEYS.USERS);\n  if (!existingUsers) {\n    localStorage.setItem(STORAGE_KEYS.USERS, JSON.stringify(DEFAULT_USERS));\n  }\n};\n\n// Authentication functions\nexport const login = async (username, password) => {\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      try {\n        initializeUsers();\n        const users = JSON.parse(localStorage.getItem(STORAGE_KEYS.USERS) || '[]');\n        const user = users.find(u => (u.username === username || u.email === username) && u.password === password);\n        if (user) {\n          const token = generateToken({\n            id: user.id,\n            username: user.username,\n            email: user.email,\n            role: user.role\n          });\n          const userData = {\n            id: user.id,\n            username: user.username,\n            email: user.email,\n            role: user.role\n          };\n          localStorage.setItem(STORAGE_KEYS.TOKEN, token);\n          localStorage.setItem(STORAGE_KEYS.USER, JSON.stringify(userData));\n          resolve({\n            token,\n            user: userData\n          });\n        } else {\n          reject(new Error('Credenciais inválidas'));\n        }\n      } catch (error) {\n        reject(new Error('Erro interno de autenticação'));\n      }\n    }, 500); // Simulate network delay\n  });\n};\nexport const logout = () => {\n  localStorage.removeItem(STORAGE_KEYS.TOKEN);\n  localStorage.removeItem(STORAGE_KEYS.USER);\n};\nexport const getCurrentUser = () => {\n  try {\n    const token = localStorage.getItem(STORAGE_KEYS.TOKEN);\n    const userStr = localStorage.getItem(STORAGE_KEYS.USER);\n    if (!token || !userStr) {\n      return null;\n    }\n    const tokenData = decodeToken(token);\n    if (!tokenData || tokenData.exp < Date.now()) {\n      // Token expired\n      logout();\n      return null;\n    }\n    return JSON.parse(userStr);\n  } catch (error) {\n    logout();\n    return null;\n  }\n};\nexport const getToken = () => {\n  const token = localStorage.getItem(STORAGE_KEYS.TOKEN);\n  if (!token) return null;\n  const tokenData = decodeToken(token);\n  if (!tokenData || tokenData.exp < Date.now()) {\n    logout();\n    return null;\n  }\n  return token;\n};\nexport const isAuthenticated = () => {\n  return getCurrentUser() !== null;\n};\nexport const hasRole = requiredRole => {\n  const user = getCurrentUser();\n  if (!user) return false;\n  const roleHierarchy = {\n    'user': 1,\n    'admin': 2\n  };\n  const userLevel = roleHierarchy[user.role] || 0;\n  const requiredLevel = roleHierarchy[requiredRole] || 0;\n  return userLevel >= requiredLevel;\n};\n\n// User management functions\nexport const registerUser = async userData => {\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      try {\n        initializeUsers();\n        const users = JSON.parse(localStorage.getItem(STORAGE_KEYS.USERS) || '[]');\n\n        // Check if user already exists\n        const existingUser = users.find(u => u.username === userData.username || u.email === userData.email);\n        if (existingUser) {\n          reject(new Error('Usuário já existe'));\n          return;\n        }\n        const newUser = {\n          id: Date.now(),\n          username: userData.username,\n          email: userData.email,\n          password: userData.password,\n          // In production, hash this\n          role: userData.role || 'user',\n          createdAt: new Date().toISOString()\n        };\n        users.push(newUser);\n        localStorage.setItem(STORAGE_KEYS.USERS, JSON.stringify(users));\n        resolve({\n          message: 'Usuário criado com sucesso'\n        });\n      } catch (error) {\n        reject(new Error('Erro ao criar usuário'));\n      }\n    }, 500);\n  });\n};\nexport const updateUserProfile = async (userId, updateData) => {\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      try {\n        const users = JSON.parse(localStorage.getItem(STORAGE_KEYS.USERS) || '[]');\n        const userIndex = users.findIndex(u => u.id === userId);\n        if (userIndex === -1) {\n          reject(new Error('Usuário não encontrado'));\n          return;\n        }\n\n        // Update user data\n        users[userIndex] = {\n          ...users[userIndex],\n          ...updateData,\n          updatedAt: new Date().toISOString()\n        };\n        localStorage.setItem(STORAGE_KEYS.USERS, JSON.stringify(users));\n\n        // Update current user if it's the same user\n        const currentUser = getCurrentUser();\n        if (currentUser && currentUser.id === userId) {\n          const updatedUser = {\n            ...currentUser,\n            ...updateData\n          };\n          localStorage.setItem(STORAGE_KEYS.USER, JSON.stringify(updatedUser));\n        }\n        resolve({\n          message: 'Perfil atualizado com sucesso'\n        });\n      } catch (error) {\n        reject(new Error('Erro ao atualizar perfil'));\n      }\n    }, 500);\n  });\n};\n\n// Session management\nexport const refreshSession = () => {\n  const user = getCurrentUser();\n  if (user) {\n    const token = generateToken(user);\n    localStorage.setItem(STORAGE_KEYS.TOKEN, token);\n    return true;\n  }\n  return false;\n};\nexport const getSessionTimeRemaining = () => {\n  const token = localStorage.getItem(STORAGE_KEYS.TOKEN);\n  if (!token) return 0;\n  const tokenData = decodeToken(token);\n  if (!tokenData) return 0;\n  const remaining = tokenData.exp - Date.now();\n  return Math.max(0, remaining);\n};\n\n// Initialize on import\ninitializeUsers();","map":{"version":3,"names":["config","JWT_SECRET","auth","jwtSecret","SESSION_TIMEOUT","sessionTimeout","generateToken","userData","payload","exp","Date","now","iat","btoa","JSON","stringify","decodeToken","token","parse","atob","error","getDefaultUsers","adminUsername","adminEmail","adminPassword","userUsername","userEmail","userPassword","Error","id","username","email","password","role","STORAGE_KEYS","TOKEN","USER","USERS","initializeUsers","existingUsers","localStorage","getItem","setItem","DEFAULT_USERS","login","Promise","resolve","reject","setTimeout","users","user","find","u","logout","removeItem","getCurrentUser","userStr","tokenData","getToken","isAuthenticated","hasRole","requiredRole","roleHierarchy","userLevel","requiredLevel","registerUser","existingUser","newUser","createdAt","toISOString","push","message","updateUserProfile","userId","updateData","userIndex","findIndex","updatedAt","currentUser","updatedUser","refreshSession","getSessionTimeRemaining","remaining","Math","max"],"sources":["C:/Users/Afonso/Desktop/Transkipta/src/services/authService.js"],"sourcesContent":["import config from '../config/env';\r\n\r\n// Local Authentication Service\r\nconst JWT_SECRET = config.auth.jwtSecret;\r\nconst SESSION_TIMEOUT = config.auth.sessionTimeout;\r\n\r\n// Simple JWT-like token generation (for demo purposes)\r\nconst generateToken = (userData) => {\r\n  const payload = {\r\n    ...userData,\r\n    exp: Date.now() + SESSION_TIMEOUT,\r\n    iat: Date.now()\r\n  };\r\n  \r\n  // In a real app, you'd use a proper JWT library\r\n  return btoa(JSON.stringify(payload));\r\n};\r\n\r\nconst decodeToken = (token) => {\r\n  try {\r\n    return JSON.parse(atob(token));\r\n  } catch (error) {\r\n    return null;\r\n  }\r\n};\r\n\r\n// Default users (in a real app, this would be handled by a proper auth service)\r\nconst getDefaultUsers = () => {\r\n  // Verificar se as credenciais estão definidas nas variáveis de ambiente\r\n  const adminUsername = config.auth.adminUsername;\r\n  const adminEmail = config.auth.adminEmail;\r\n  const adminPassword = config.auth.adminPassword;\r\n  const userUsername = config.auth.userUsername;\r\n  const userEmail = config.auth.userEmail;\r\n  const userPassword = config.auth.userPassword;\r\n  \r\n  if (!adminUsername || !adminEmail || !adminPassword || !userUsername || !userEmail || !userPassword) {\r\n    throw new Error('Credenciais de usuário não configuradas nas variáveis de ambiente');\r\n  }\r\n  \r\n  return [\r\n    {\r\n      id: 1,\r\n      username: adminUsername,\r\n      email: adminEmail,\r\n      password: adminPassword, // In production, this would be hashed\r\n      role: 'admin'\r\n    },\r\n    {\r\n      id: 2,\r\n      username: userUsername,\r\n      email: userEmail,\r\n      password: userPassword,\r\n      role: 'user'\r\n    }\r\n  ];\r\n};\r\n\r\n// Storage keys\r\nconst STORAGE_KEYS = {\r\n  TOKEN: 'transkipta_token',\r\n  USER: 'transkipta_user',\r\n  USERS: 'transkipta_users'\r\n};\r\n\r\n// Initialize default users if not exists\r\nconst initializeUsers = () => {\r\n  const existingUsers = localStorage.getItem(STORAGE_KEYS.USERS);\r\n  if (!existingUsers) {\r\n    localStorage.setItem(STORAGE_KEYS.USERS, JSON.stringify(DEFAULT_USERS));\r\n  }\r\n};\r\n\r\n// Authentication functions\r\nexport const login = async (username, password) => {\r\n  return new Promise((resolve, reject) => {\r\n    setTimeout(() => {\r\n      try {\r\n        initializeUsers();\r\n        const users = JSON.parse(localStorage.getItem(STORAGE_KEYS.USERS) || '[]');\r\n        \r\n        const user = users.find(u => \r\n          (u.username === username || u.email === username) && u.password === password\r\n        );\r\n        \r\n        if (user) {\r\n          const token = generateToken({\r\n            id: user.id,\r\n            username: user.username,\r\n            email: user.email,\r\n            role: user.role\r\n          });\r\n          \r\n          const userData = {\r\n            id: user.id,\r\n            username: user.username,\r\n            email: user.email,\r\n            role: user.role\r\n          };\r\n          \r\n          localStorage.setItem(STORAGE_KEYS.TOKEN, token);\r\n          localStorage.setItem(STORAGE_KEYS.USER, JSON.stringify(userData));\r\n          \r\n          resolve({ token, user: userData });\r\n        } else {\r\n          reject(new Error('Credenciais inválidas'));\r\n        }\r\n      } catch (error) {\r\n        reject(new Error('Erro interno de autenticação'));\r\n      }\r\n    }, 500); // Simulate network delay\r\n  });\r\n};\r\n\r\nexport const logout = () => {\r\n  localStorage.removeItem(STORAGE_KEYS.TOKEN);\r\n  localStorage.removeItem(STORAGE_KEYS.USER);\r\n};\r\n\r\nexport const getCurrentUser = () => {\r\n  try {\r\n    const token = localStorage.getItem(STORAGE_KEYS.TOKEN);\r\n    const userStr = localStorage.getItem(STORAGE_KEYS.USER);\r\n    \r\n    if (!token || !userStr) {\r\n      return null;\r\n    }\r\n    \r\n    const tokenData = decodeToken(token);\r\n    if (!tokenData || tokenData.exp < Date.now()) {\r\n      // Token expired\r\n      logout();\r\n      return null;\r\n    }\r\n    \r\n    return JSON.parse(userStr);\r\n  } catch (error) {\r\n    logout();\r\n    return null;\r\n  }\r\n};\r\n\r\nexport const getToken = () => {\r\n  const token = localStorage.getItem(STORAGE_KEYS.TOKEN);\r\n  if (!token) return null;\r\n  \r\n  const tokenData = decodeToken(token);\r\n  if (!tokenData || tokenData.exp < Date.now()) {\r\n    logout();\r\n    return null;\r\n  }\r\n  \r\n  return token;\r\n};\r\n\r\nexport const isAuthenticated = () => {\r\n  return getCurrentUser() !== null;\r\n};\r\n\r\nexport const hasRole = (requiredRole) => {\r\n  const user = getCurrentUser();\r\n  if (!user) return false;\r\n  \r\n  const roleHierarchy = {\r\n    'user': 1,\r\n    'admin': 2\r\n  };\r\n  \r\n  const userLevel = roleHierarchy[user.role] || 0;\r\n  const requiredLevel = roleHierarchy[requiredRole] || 0;\r\n  \r\n  return userLevel >= requiredLevel;\r\n};\r\n\r\n// User management functions\r\nexport const registerUser = async (userData) => {\r\n  return new Promise((resolve, reject) => {\r\n    setTimeout(() => {\r\n      try {\r\n        initializeUsers();\r\n        const users = JSON.parse(localStorage.getItem(STORAGE_KEYS.USERS) || '[]');\r\n        \r\n        // Check if user already exists\r\n        const existingUser = users.find(u => \r\n          u.username === userData.username || u.email === userData.email\r\n        );\r\n        \r\n        if (existingUser) {\r\n          reject(new Error('Usuário já existe'));\r\n          return;\r\n        }\r\n        \r\n        const newUser = {\r\n          id: Date.now(),\r\n          username: userData.username,\r\n          email: userData.email,\r\n          password: userData.password, // In production, hash this\r\n          role: userData.role || 'user',\r\n          createdAt: new Date().toISOString()\r\n        };\r\n        \r\n        users.push(newUser);\r\n        localStorage.setItem(STORAGE_KEYS.USERS, JSON.stringify(users));\r\n        \r\n        resolve({ message: 'Usuário criado com sucesso' });\r\n      } catch (error) {\r\n        reject(new Error('Erro ao criar usuário'));\r\n      }\r\n    }, 500);\r\n  });\r\n};\r\n\r\nexport const updateUserProfile = async (userId, updateData) => {\r\n  return new Promise((resolve, reject) => {\r\n    setTimeout(() => {\r\n      try {\r\n        const users = JSON.parse(localStorage.getItem(STORAGE_KEYS.USERS) || '[]');\r\n        const userIndex = users.findIndex(u => u.id === userId);\r\n        \r\n        if (userIndex === -1) {\r\n          reject(new Error('Usuário não encontrado'));\r\n          return;\r\n        }\r\n        \r\n        // Update user data\r\n        users[userIndex] = {\r\n          ...users[userIndex],\r\n          ...updateData,\r\n          updatedAt: new Date().toISOString()\r\n        };\r\n        \r\n        localStorage.setItem(STORAGE_KEYS.USERS, JSON.stringify(users));\r\n        \r\n        // Update current user if it's the same user\r\n        const currentUser = getCurrentUser();\r\n        if (currentUser && currentUser.id === userId) {\r\n          const updatedUser = { ...currentUser, ...updateData };\r\n          localStorage.setItem(STORAGE_KEYS.USER, JSON.stringify(updatedUser));\r\n        }\r\n        \r\n        resolve({ message: 'Perfil atualizado com sucesso' });\r\n      } catch (error) {\r\n        reject(new Error('Erro ao atualizar perfil'));\r\n      }\r\n    }, 500);\r\n  });\r\n};\r\n\r\n// Session management\r\nexport const refreshSession = () => {\r\n  const user = getCurrentUser();\r\n  if (user) {\r\n    const token = generateToken(user);\r\n    localStorage.setItem(STORAGE_KEYS.TOKEN, token);\r\n    return true;\r\n  }\r\n  return false;\r\n};\r\n\r\nexport const getSessionTimeRemaining = () => {\r\n  const token = localStorage.getItem(STORAGE_KEYS.TOKEN);\r\n  if (!token) return 0;\r\n  \r\n  const tokenData = decodeToken(token);\r\n  if (!tokenData) return 0;\r\n  \r\n  const remaining = tokenData.exp - Date.now();\r\n  return Math.max(0, remaining);\r\n};\r\n\r\n// Initialize on import\r\ninitializeUsers();"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}